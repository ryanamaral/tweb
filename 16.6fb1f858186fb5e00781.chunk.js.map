{"version":3,"sources":["webpack:///./src/lib/rootScope.ts","webpack:///./src/helpers/schedulers.ts","webpack:///./src/helpers/touchSupport.ts","webpack:///./src/components/ripple.ts","webpack:///./src/helpers/cancellablePromise.ts","webpack:///./src/helpers/eventListenerBase.ts","webpack:///./src/helpers/dom/isInDOM.ts","webpack:///./src/helpers/sequentialDom.ts","webpack:///./src/config/modes.ts","webpack:///./src/config/debug.ts"],"names":["RootScope","super","_overlayIsActive","myId","idle","isIDLE","focusPromise","Promise","resolve","focusResolve","connectionStatus","peerId","broadcast","name","detail","this","dispatchEvent","on","callback","once","addEventListener","off","removeEventListener","e","status","darkModeMediaQuery","window","matchMedia","checkDarkMode","systemTheme","matches","setTheme","isNight","getTheme","colorScheme","document","head","querySelector","setAttribute","documentElement","classList","toggle","value","settings","theme","themes","find","t","rootScope","debounce","fn","ms","shouldRunFirst","shouldRunLast","waitingTimeout","args","clearTimeout","setTimeout","throttle","isPending","interval","_args","setInterval","clearInterval","pause","fastRafCallbacks","fastRaf","push","requestAnimationFrame","currentCallbacks","undefined","forEach","cb","doubleRaf","isTouchSupported","DocumentTouch","rippleClickId","ripple","elem","onEnd","prepend","add","r","createElement","handler","contains","drawRipple","clientX","clientY","startTime","Date","now","clickId","duration","getComputedStyle","getPropertyValue","replace","elapsedTime","mutate","remove","delay","Math","max","touchStartFired","rect","getBoundingClientRect","clickX","left","clickY","top","size","sqrt","abs","height","width","x","y","style","append","isRippleUnneeded","target","includes","tagName","touchEnd","animationsEnabled","touches","length","cancelBubble","stopPropagation","passive","button","dataset","deferredPromise","deferredHelper","isFulfilled","isRejected","notify","notifyAll","lastNotify","listeners","addNotifyListener","deferred","reject","finally","cancel","Object","assign","EventListenerBase","reuseResults","_constructor","listenerResults","hasOwnProperty","obj","i","findAndSplice","l","arr","slice","listener","findIndex","isInDOM","element","isConnected","sequentialDom","promises","raf","bind","scheduled","kind","promise","scheduleFlush","then","do","read","write","Modes","test","location","search","indexOf","debug","http","ssl","multipleConnections","asServiceWorker","DEBUG","MOUNT_CLASS_TO","self"],"mappings":"4FAAA,oEAmHO,MAAMA,UAAkB,IAiB7B,cACEC,QAbM,KAAAC,kBAA4B,EAC7B,KAAAC,KAAO,EACP,KAAAC,KAAO,CACZC,QAAQ,EACRC,aAAcC,QAAQC,UACtBC,aAAc,QAET,KAAAC,iBAA6D,GAE7D,KAAAC,OAAS,EAsET,KAAAC,UAAY,CAAkCC,EAASC,KAO5DC,KAAKC,cAAcH,EAAMC,IAGpB,KAAAG,GAAK,CAAkCJ,EAASK,EAA0CC,KAC/FlB,MAAMmB,iBAAiBP,EAAMK,EAAUC,IAGlC,KAAAC,iBAAmBL,KAAKE,GAExB,KAAAI,IAAM,CAAkCR,EAASK,KACtDjB,MAAMqB,oBAAoBT,EAAMK,IAG3B,KAAAI,oBAAsBP,KAAKM,IApFhCN,KAAKE,GAAG,eAAiBN,IACvBI,KAAKJ,OAASA,IAGhBI,KAAKE,GAAG,YAAcM,IACpBR,KAAKZ,KAAOoB,IAGdR,KAAKE,GAAG,2BAA6BM,IACnC,MAAMC,EAASD,EACfR,KAAKL,iBAAiBa,EAAEV,MAAQW,IAGlCT,KAAKE,GAAG,OAASZ,IACZA,EACDU,KAAKX,KAAKE,aAAe,IAAIC,QAASC,IACpCO,KAAKX,KAAKK,aAAeD,IAG3BO,KAAKX,KAAKK,iBAKT,mBACL,MAAMgB,EAAqBC,OAAOC,WAAW,gCACvCC,EAAgB,KAEpBb,KAAKc,YAAcJ,EAAmBK,QAAU,QAAU,MAGvDf,KAAKZ,KACNY,KAAKH,UAAU,gBAEfG,KAAKgB,YAGTN,EAAmBL,iBAAiB,SAAUQ,GAC9CA,IAGK,WACL,MAAMI,EAAmC,UAAzBjB,KAAKkB,WAAWpB,KAC1BqB,EAAcC,SAASC,KAAKC,cAAc,yBAC7CH,GACDA,EAAYI,aAAa,UAAWN,EAAU,OAAS,SAGzDG,SAASI,gBAAgBC,UAAUC,OAAO,QAAST,GAGrD,sBACE,OAAOjB,KAAKb,iBAGd,oBAAoBwC,GAClB3B,KAAKb,iBAAmBwC,EACxB3B,KAAKH,UAAU,iBAAkB8B,GAG5B,SAAS7B,GAA8C,WAAxBE,KAAK4B,SAASC,MAAqB7B,KAAKc,YAAcd,KAAK4B,SAASC,QACxG,OAAO7B,KAAK4B,SAASE,OAAOC,KAAKC,GAAKA,EAAElC,OAASA,IA0BrD,MAAMmC,EAAY,IAAIhD,EACtB,IAAegD,UAAYA,EACZ,a,gCCrNR,SAASC,EACdC,EACAC,EACAC,GAAiB,EACjBC,GAAgB,GAEhB,IAAIC,EAAgC,KAEpC,MAAO,IAAIC,KACND,GACDE,aAAaF,GACbA,EAAiB,MACTF,GAERF,KAAMK,GAGRD,EAAiBG,WAAW,KACvBJ,GAEDH,KAAMK,GAGRD,EAAiB,MAChBH,IAIA,SAASO,EACdR,EACAC,EACAC,GAAiB,GAEjB,IACIO,EACAJ,EAFAK,EAA0B,KAI9B,MAAO,IAAIC,KACTF,GAAY,EACZJ,EAAOM,EAEHD,IACCR,IACDO,GAAY,EAEZT,KAAMK,IAGRK,EAAWE,YAAY,KACrB,IAAKH,EAGH,OAFAI,cAAcH,QACdA,EAAW,MAIbD,GAAY,EAEZT,KAAMK,IACLJ,KArET,0KAiHO,MAAMa,EAASb,GAAe,IAAI5C,QAAeC,IACtDiD,WAAWjD,EAAS2C,KAGtB,IAAIc,EACG,SAASC,EAAQhD,GAClB+C,EASFA,EAAiBE,KAAKjD,IARtB+C,EAAmB,CAAC/C,GAEpBkD,sBAAsB,KACpB,MAAMC,EAAmBJ,EACzBA,OAAmBK,EACnBD,EAAiBE,QAASC,GAAOA,QAOhC,SAASC,IACd,OAAO,IAAIlE,QAAeC,IACxB0D,EAAQ,KACNA,EAAQ1D,S,gCCvId,wDAOO,MAAMkE,EAAoB,iBAAkBhD,QAAYA,OAAOiD,eAAiBxC,oBAAoBwC,e,gCCP3G,iFAWA,IAAIC,EAAgB,EACb,SAASC,EAAOC,EAAmB5D,EAAoD,KAAMX,QAAQC,WAAWuE,EAA8B,KAAMC,GAAU,GAEnK,GAAGF,EAAKzC,cAAc,aAAc,OACpCyC,EAAKtC,UAAUyC,IAAI,MAEnB,IAAIC,EAAI/C,SAASgD,cAAc,OAC/BD,EAAE1C,UAAUyC,IAAI,YAShB,IAAIG,EAPaN,EAAKtC,UAAU6C,SAAS,cAEvCH,EAAE1C,UAAUyC,IAAI,aAGlBH,EAAKE,EAAU,UAAY,UAAUE,GAIrC,MAAMI,EAAa,CAACC,EAAiBC,KACnC,MAAMC,EAAYC,KAAKC,MACjBb,EAAO3C,SAASgD,cAAc,OAE9BS,EAAUhB,IAIViB,EAAgG,KAApFnE,OAAOoE,iBAAiBZ,GAAGa,iBAAiB,qBAAqBC,QAAQ,IAAK,IAGhGZ,EAAU,KAMR,IAAIa,EAAcP,KAAKC,MAAQF,EAC/B,MAAMjB,EAAK,KAET,IAAc0B,OAAO,KACnBpB,EAAKqB,WAGJpB,GAAOA,EAAMa,IAElB,GAAGK,EAAcJ,EAAU,CACzB,IAAIO,EAAQC,KAAKC,IAAIT,EAAWI,EAAaJ,EAAW,GACxDpC,WAAW,IAAMqB,EAAKtC,UAAUyC,IAAI,UAAWoB,KAAKC,IAAIF,EAAQP,EAAW,EAAG,IAE9EpC,WAAWe,EAAI4B,QAEftB,EAAKtC,UAAUyC,IAAI,UACnBxB,WAAWe,EAAIqB,EAAW,GAGxB,oBACFnE,OAAOJ,oBAAoB,cAAe8D,GAG5CA,EAAU,KACVmB,GAAkB,GAIpBrF,GAAYA,EAAS0E,GAenBlE,OAAO0C,sBAAsB,KAC3B,MAAMoC,EAAOtB,EAAEuB,wBACf3B,EAAKtC,UAAUyC,IAAI,oBAEnB,MAAMyB,EAASnB,EAAUiB,EAAKG,KACxBC,EAASpB,EAAUgB,EAAKK,IAGxBC,EADST,KAAKU,KAAK,SAACV,KAAKW,IAAIJ,EAASJ,EAAKS,OAAS,GAAKT,EAAKS,OAAS,EAAM,GAAI,SAACZ,KAAKW,IAAIN,EAASF,EAAKU,MAAQ,GAAKV,EAAKU,MAAQ,EAAM,IAIzIC,EAAIT,EAASI,EAAO,EACpBM,EAAIR,EAASE,EAAO,EAI1BhC,EAAKuC,MAAMH,MAAQpC,EAAKuC,MAAMJ,OAASH,EAAO,KAC9ChC,EAAKuC,MAAMV,KAAOQ,EAAI,KACtBrC,EAAKuC,MAAMR,IAAMO,EAAI,KAgBrBlC,EAAEoC,OAAOxC,MAQTyC,EAAoBhG,GAAaA,EAAEiG,SAAW1C,IAChD,CAAC,SAAU,KAAK2C,SAAUlG,EAAEiG,OAAuBE,UAChD,YAAgBnG,EAAEiG,OAAuB,cAAgBtC,GAIhE,IAAIqB,GAAkB,EACtB,GAAG,mBAAkB,CACnB,IAAIoB,EAAW,KACbvC,GAAWA,KAGbN,EAAK1D,iBAAiB,aAAeG,IACnC,IAAI,UAAUoB,SAASiF,kBACrB,OAIF,GAAGrG,EAAEsG,QAAQC,OAAS,GAAKvB,GAAmBgB,EAAiBhG,GAC7D,OAIFgF,GAAkB,EAElB,IAAI,QAAChB,EAAO,QAAEC,GAAWjE,EAAEsG,QAAQ,GACnCvC,EAAWC,EAASC,GACpBV,EAAK1D,iBAAiB,WAAYuG,EAAU,CAACxG,MAAM,IAEnDO,OAAON,iBAAiB,YAAcG,IACpCA,EAAEwG,cAAe,EACjBxG,EAAEyG,kBACFL,IACA7C,EAAKxD,oBAAoB,WAAYqG,IACpC,CAACxG,MAAM,KACT,CAAC8G,SAAS,SAEbnD,EAAK1D,iBAAiB,YAAcG,IAClC,IAAI,CAAC,EAAG,GAAGkG,SAASlG,EAAE2G,QACpB,OAGF,IAAI,UAAUvF,SAASiF,kBACrB,OAIF,GAA2B,MAAxB9C,EAAKqD,QAAQtD,QAAkB0C,EAAiBhG,GACjD,OACK,GAAGgF,EAER,YADAA,GAAkB,GAIpB,IAAI,QAAChB,EAAO,QAAEC,GAAWjE,EACzB+D,EAAWC,EAASC,GACpB9D,OAAON,iBAAiB,UAAWgE,EAAS,CAACjE,MAAM,EAAM8G,SAAS,IAClEvG,OAAON,iBAAiB,cAAegE,EAAS,CAACjE,MAAM,EAAM8G,SAAS,KACrE,CAACA,SAAS,M,gCCxKV,SAASG,IACd,IAAIC,EAAsB,CACxBC,aAAa,EACbC,YAAY,EAEZC,OAAQ,OACRC,UAAW,IAAIlF,KACb8E,EAAeK,WAAanF,EAC5B8E,EAAeM,UAAUpE,QAASrD,GAAkBA,KAAYqC,KAGlEmF,gBAAYpE,EACZqE,UAAW,GACXC,kBAAoB1H,IACfmH,EAAeK,YAChBxH,KAAYmH,EAAeK,YAG7BL,EAAeM,UAAUxE,KAAKjD,KAI9B2H,EAAkC,IAAItI,QAAW,CAACC,EAASsI,KAC7DT,EAAe7H,QAAWkC,IACrBmG,EAASP,cAEZO,EAASP,aAAc,EACvB9H,EAAQkC,KAGV2F,EAAeS,OAAS,IAAIvF,KACvBsF,EAASN,aAEZM,EAASN,YAAa,EACtBO,KAAUvF,OAsBd,OAZAsF,EAASE,QAAQ,KACfF,EAASL,OAAS,KAClBK,EAASF,UAAUb,OAAS,EAC5Be,EAASH,WAAa,KAEnBG,EAASG,SACVH,EAASG,OAAS,UAItBC,OAAOC,OAAOL,EAAUR,GAEjBQ,EA7ET,mC,gCCAA,kCAuDe,MAAMM,EAUnB,YAAYC,GACVrI,KAAKsI,aAAaD,GAGb,aAAaA,GAAe,GACjCrI,KAAKqI,aAAeA,EACpBrI,KAAK4H,UAAY,GACjB5H,KAAKuI,gBAAkB,GAGlB,iBAAiBzI,EAAuBK,EAAkCC,G,MAC5EJ,KAAKuI,gBAAgBC,eAAe1I,KACrCK,KAAYH,KAAKuI,gBAAgBzI,IAE9BM,KAKgB,QAApB,EAAAJ,KAAK4H,UAAU9H,UAAK,QAAKE,KAAK4H,UAAU9H,GAAQ,IAAKsD,KAAK,CAACjD,WAAUC,SAIjE,2BAA2BqI,GAGhC,IAAI,MAAMC,KAAKD,EACbzI,KAAKK,iBAAiBqI,EAAGD,EAAIC,IAI1B,oBAAoB5I,EAAuBK,GAC7CH,KAAK4H,UAAU9H,IAChBE,KAAK4H,UAAU9H,GAAM6I,cAAcC,GAAKA,EAAEzI,WAAaA,GAMpD,cAAcL,KAA0B0C,GAC1CxC,KAAKqI,eACNrI,KAAKuI,gBAAgBzI,GAAQ0C,GAG/B,MAAMqG,EAAsD,GAKtDjB,EAAY5H,KAAK4H,UAAU9H,GACjC,GAAG8H,EAAW,CAECA,EAAUkB,QAClBtF,QAASuF,KAEE,IADAnB,EAAUoB,UAAWJ,GAAWA,EAAEzI,WAAa4I,EAAS5I,YAKtE0I,EAAIzF,KAAK2F,EAAS5I,YAAYqC,IAE3BuG,EAAS3I,MACVJ,KAAKO,oBAAoBT,EAAMiJ,EAAS5I,aAgB9C,OAAO0I,EAGF,UACL7I,KAAK4H,UAAY,GACjB5H,KAAKuI,gBAAkB,M,gCC9HZ,SAASU,EAAQC,GAC9B,OAAOA,aAAO,EAAPA,EAASC,YAvBlB,mC,gCCAA,mCAiEA,MAAMC,EAAgB,IA5DtB,oBACU,KAAAC,SAGH,GACG,KAAAC,IAAM,IAAQC,KAAK,MACnB,KAAAC,WAAY,EAEZ,GAAGC,EAAuCtJ,GAChD,IAAIuJ,EAAU1J,KAAKqJ,SAASI,GAU5B,OATIC,IACF1J,KAAK2J,gBACLD,EAAU1J,KAAKqJ,SAASI,GAAQ,oBAGlBlG,IAAbpD,GACDuJ,EAAQE,KAAK,IAAMzJ,KAGduJ,EAGF,QAAQvJ,GACb,OAAOH,KAAK6J,GAAG,OAAQ1J,GAGlB,OAAOA,GACZ,OAAOH,KAAK6J,GAAG,QAAS1J,GAQnB,cAAc+I,EAAsB/I,GACzC,MAAMuJ,EAAU,YAAQR,GAAWlJ,KAAKmF,SAAW3F,QAAQC,UAM3D,YAJgB8D,IAAbpD,GACDuJ,EAAQE,KAAK,IAAMzJ,KAGduJ,EAGD,gBACF1J,KAAKwJ,YACPxJ,KAAKwJ,WAAY,EAEjBxJ,KAAKsJ,IAAI,KACPtJ,KAAKqJ,SAASS,MAAQ9J,KAAKqJ,SAASS,KAAKrK,UACzCO,KAAKqJ,SAASU,OAAS/J,KAAKqJ,SAASU,MAAMtK,UAE3CO,KAAKwJ,WAAY,EACjBxJ,KAAKqJ,SAAW,QAOxB,MAAmB,IAAeD,cAAgBA,GACnC,O,gCCxDf,MAAMY,EAAQ,CACZC,KAAMC,SAASC,OAAOC,QAAQ,UAAY,EAC1CC,MAAOH,SAASC,OAAOC,QAAQ,WAAa,EAC5CE,MAAM,EACNC,KAAK,EACLC,qBAAqB,EACrBC,iBAAiB,GAOJ,O,+BCxBf,kCAQO,MAAMC,EARb,MAQ8D,EAAML,MAEvDM,EADuB,oBAAb,OAA2BhK,OAASiK,KAE5C","file":"16.6fb1f858186fb5e00781.chunk.js","sourcesContent":["/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport type { Message, StickerSet, Update, NotifyPeer, PeerNotifySettings, ConstructorDeclMap } from \"../layer\";\nimport type { MyDocument } from \"./appManagers/appDocsManager\";\nimport type { AppMessagesManager, Dialog, MessagesStorage } from \"./appManagers/appMessagesManager\";\nimport type { Poll, PollResults } from \"./appManagers/appPollsManager\";\nimport type { MyDialogFilter } from \"./storages/filters\";\nimport type { ConnectionStatusChange } from \"../types\";\nimport type { UserTyping } from \"./appManagers/appChatsManager\";\nimport type Chat from \"../components/chat/chat\";\nimport type { UserAuth } from \"./mtproto/mtproto_config\";\nimport type { State, Theme } from \"./appManagers/appStateManager\";\nimport type { MyDraftMessage } from \"./appManagers/appDraftsManager\";\nimport EventListenerBase from \"../helpers/eventListenerBase\";\nimport { MOUNT_CLASS_TO } from \"../config/debug\";\n\nexport type BroadcastEvents = {\n  'user_update': number,\n  'user_auth': UserAuth,\n  'peer_changed': number,\n  'peer_changing': Chat,\n  'peer_pinned_messages': {peerId: number, mids?: number[], pinned?: boolean, unpinAll?: true},\n  'peer_pinned_hidden': {peerId: number, maxId: number},\n  'peer_typings': {peerId: number, typings: UserTyping[]},\n  'peer_block': {peerId: number, blocked: boolean},\n  'peer_title_edit': number,\n  'peer_bio_edit': number,\n\n  'filter_delete': MyDialogFilter,\n  'filter_update': MyDialogFilter,\n  'filter_order': number[],\n  \n  'dialog_draft': {peerId: number, draft: MyDraftMessage | undefined, index: number},\n  'dialog_unread': {peerId: number},\n  'dialog_flush': {peerId: number},\n  'dialog_drop': {peerId: number, dialog?: Dialog},\n  'dialog_migrate': {migrateFrom: number, migrateTo: number},\n  //'dialog_top': Dialog,\n  'dialog_notify_settings': Dialog,\n  'dialogs_multiupdate': {[peerId: string]: Dialog},\n  'dialogs_archived_unread': {count: number},\n  \n  'history_append': {storage: MessagesStorage, peerId: number, mid: number},\n  'history_update': {storage: MessagesStorage, peerId: number, mid: number},\n  'history_reply_markup': {peerId: number},\n  'history_multiappend': AppMessagesManager['newMessagesToHandle'],\n  'history_delete': {peerId: number, msgs: {[mid: number]: true}},\n  'history_forbidden': number,\n  'history_reload': number,\n  'history_focus': {peerId: number, mid?: number},\n  //'history_request': void,\n  \n  'message_edit': {storage: MessagesStorage, peerId: number, mid: number},\n  'message_views': {mid: number, views: number},\n  'message_sent': {storage: MessagesStorage, tempId: number, tempMessage: any, mid: number},\n  'messages_pending': void,\n  'messages_read': void,\n  'messages_downloaded': {peerId: number, mids: number[]},\n  'messages_media_read': {peerId: number, mids: number[]},\n\n  'replies_updated': Message.message,\n\n  'scheduled_new': {peerId: number, mid: number},\n  'scheduled_delete': {peerId: number, mids: number[]},\n\n  'album_edit': {peerId: number, groupId: string, deletedMids: number[]},\n\n  'stickers_installed': StickerSet.stickerSet,\n  'stickers_deleted': StickerSet.stickerSet,\n\n  'audio_play': {doc: MyDocument, mid: number, peerId: number},\n  'audio_pause': void,\n  \n  'state_synchronized': number,\n  'state_synchronizing': number,\n  \n  'contacts_update': number,\n  'avatar_update': number,\n  'chat_full_update': number,\n  'poll_update': {poll: Poll, results: PollResults},\n  'chat_update': number,\n  //'channel_settings': {channelId: number},\n  'webpage_updated': {id: string, msgs: number[]},\n\n  'download_progress': any,\n  'connection_status_change': ConnectionStatusChange,\n  'settings_updated': {key: string, value: any},\n  'draft_updated': {peerId: number, threadId: number, draft: MyDraftMessage | undefined},\n\n  'event-heavy-animation-start': void,\n  'event-heavy-animation-end': void,\n\n  'im_mount': void,\n  'im_tab_change': number,\n\n  'idle': boolean,\n\n  'overlay_toggle': boolean,\n\n  'background_change': void,\n\n  'privacy_update': Update.updatePrivacy,\n\n  'notify_settings': Update.updateNotifySettings,\n  'notify_peer_type_settings': {key: Exclude<NotifyPeer['_'], 'notifyPeer'>, settings: PeerNotifySettings},\n\n  'language_change': void,\n  \n  'theme_change': void,\n};\n\nexport class RootScope extends EventListenerBase<{\n  [name in Update['_']]: (update: ConstructorDeclMap[name]) => void\n} & {\n  [name in keyof BroadcastEvents]: (e: BroadcastEvents[name]) => void\n}> {\n  private _overlayIsActive: boolean = false;\n  public myId = 0;\n  public idle = {\n    isIDLE: true,\n    focusPromise: Promise.resolve(),\n    focusResolve: () => {}\n  };\n  public connectionStatus: {[name: string]: ConnectionStatusChange} = {};\n  public settings: State['settings'];\n  public peerId = 0;\n  public systemTheme: Theme['name'];\n\n  constructor() {\n    super();\n\n    this.on('peer_changed', (peerId) => {\n      this.peerId = peerId;\n    });\n\n    this.on('user_auth', (e) => {\n      this.myId = e;\n    });\n\n    this.on('connection_status_change', (e) => {\n      const status = e;\n      this.connectionStatus[e.name] = status;\n    });\n\n    this.on('idle', (isIDLE) => {\n      if(isIDLE) {\n        this.idle.focusPromise = new Promise((resolve) => {\n          this.idle.focusResolve = resolve;\n        });\n      } else {\n        this.idle.focusResolve();\n      }\n    });\n  }\n\n  public setThemeListener() {\n    const darkModeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');\n    const checkDarkMode = () => {\n      //const theme = this.getTheme();\n      this.systemTheme = darkModeMediaQuery.matches ? 'night' : 'day';\n      //const newTheme = this.getTheme();\n\n      if(this.myId) {\n        this.broadcast('theme_change');\n      } else {\n        this.setTheme();\n      }\n    };\n    darkModeMediaQuery.addEventListener('change', checkDarkMode);\n    checkDarkMode();\n  }\n\n  public setTheme() {\n    const isNight = this.getTheme().name === 'night';\n    const colorScheme = document.head.querySelector('[name=\"color-scheme\"]');\n    if(colorScheme) {\n      colorScheme.setAttribute('content', isNight ? 'dark' : 'light');\n    }\n\n    document.documentElement.classList.toggle('night', isNight);\n  }\n\n  get overlayIsActive() {\n    return this._overlayIsActive;\n  }\n\n  set overlayIsActive(value: boolean) {\n    this._overlayIsActive = value;\n    this.broadcast('overlay_toggle', value);\n  }\n\n  public getTheme(name: Theme['name'] = this.settings.theme === 'system' ? this.systemTheme : this.settings.theme) {\n    return this.settings.themes.find(t => t.name === name);\n  }\n\n  public broadcast = <T extends keyof BroadcastEvents>(name: T, detail?: BroadcastEvents[T]) => {\n    /* //if(DEBUG) {\n      if(name !== 'user_update') {\n        console.debug('Broadcasting ' + name + ' event, with args:', detail);\n      }\n    //} */\n\n    this.dispatchEvent(name, detail);\n  };\n\n  public on = <T extends keyof BroadcastEvents>(name: T, callback: (e: BroadcastEvents[T]) => any, once?: true) => {\n    super.addEventListener(name, callback, once);\n  };\n\n  public addEventListener = this.on;\n\n  public off = <T extends keyof BroadcastEvents>(name: T, callback: (e: BroadcastEvents[T]) => any) => {\n    super.removeEventListener(name, callback);\n  };\n\n  public removeEventListener = this.off;\n}\n\nconst rootScope = new RootScope();\nMOUNT_CLASS_TO.rootScope = rootScope;\nexport default rootScope;\n\n/* rootScope.addEventListener('album_edit', (e) => {\n  \n});\n\nrootScope.addEventListener<'album_edit'>('album_edit', (e) => {\n  \n}); */\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\n// * Jolly Cobra's schedulers\nimport { AnyToVoidFunction, NoneToVoidFunction } from \"../types\";\n\n//type Scheduler = typeof requestAnimationFrame | typeof onTickEnd | typeof runNow;\n\nexport function debounce<F extends AnyToVoidFunction>(\n  fn: F,\n  ms: number,\n  shouldRunFirst = true,\n  shouldRunLast = true,\n) {\n  let waitingTimeout: number | null = null;\n\n  return (...args: Parameters<F>) => {\n    if(waitingTimeout) {\n      clearTimeout(waitingTimeout);\n      waitingTimeout = null;\n    } else if(shouldRunFirst) {\n      // @ts-ignore\n      fn(...args);\n    }\n\n    waitingTimeout = setTimeout(() => {\n      if(shouldRunLast) {\n        // @ts-ignore\n        fn(...args);\n      }\n\n      waitingTimeout = null;\n    }, ms) as any;\n  };\n}\n\nexport function throttle<F extends AnyToVoidFunction>(\n  fn: F,\n  ms: number,\n  shouldRunFirst = true,\n) {\n  let interval: number | null = null;\n  let isPending: boolean;\n  let args: Parameters<F>;\n\n  return (..._args: Parameters<F>) => {\n    isPending = true;\n    args = _args;\n\n    if(!interval) {\n      if(shouldRunFirst) {\n        isPending = false;\n        // @ts-ignore\n        fn(...args);\n      }\n\n      interval = setInterval(() => {\n        if (!isPending) {\n          clearInterval(interval!);\n          interval = null;\n          return;\n        }\n\n        isPending = false;\n        // @ts-ignore\n        fn(...args);\n      }, ms) as any;\n    }\n  };\n}\n\n/* export function throttleWithRaf<F extends AnyToVoidFunction>(fn: F) {\n  return throttleWith(fastRaf, fn);\n}\n\nexport function throttleWithTickEnd<F extends AnyToVoidFunction>(fn: F) {\n  return throttleWith(onTickEnd, fn);\n}\n\nexport function throttleWithNow<F extends AnyToVoidFunction>(fn: F) {\n  return throttleWith(runNow, fn);\n}\n\nexport function throttleWith<F extends AnyToVoidFunction>(schedulerFn: Scheduler, fn: F) {\n  let waiting = false;\n  let args: Parameters<F>;\n\n  return (..._args: Parameters<F>) => {\n    args = _args;\n\n    if (!waiting) {\n      waiting = true;\n\n      schedulerFn(() => {\n        waiting = false;\n        // @ts-ignore\n        fn(...args);\n      });\n    }\n  };\n}\n\nexport function onTickEnd(cb: NoneToVoidFunction) {\n  Promise.resolve().then(cb);\n}\n\nfunction runNow(fn: NoneToVoidFunction) {\n  fn();\n} */\n\nexport const pause = (ms: number) => new Promise<void>((resolve) => {\n  setTimeout(resolve, ms);\n});\n\nlet fastRafCallbacks: NoneToVoidFunction[] | undefined;\nexport function fastRaf(callback: NoneToVoidFunction) {\n  if(!fastRafCallbacks) {\n    fastRafCallbacks = [callback];\n\n    requestAnimationFrame(() => {\n      const currentCallbacks = fastRafCallbacks!;\n      fastRafCallbacks = undefined;\n      currentCallbacks.forEach((cb) => cb());\n    });\n  } else {\n    fastRafCallbacks.push(callback);\n  }\n}\n\nexport function doubleRaf() {\n  return new Promise<void>((resolve) => {\n    fastRaf(() => {\n      fastRaf(resolve);\n    });\n  });\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\n// @ts-ignore\nexport const isTouchSupported = ('ontouchstart' in window) || (window.DocumentTouch && document instanceof DocumentTouch)/*  || true */;","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport findUpClassName from \"../helpers/dom/findUpClassName\";\nimport sequentialDom from \"../helpers/sequentialDom\";\nimport {isTouchSupported} from \"../helpers/touchSupport\";\nimport rootScope from \"../lib/rootScope\";\n\nlet rippleClickId = 0;\nexport function ripple(elem: HTMLElement, callback: (id: number) => Promise<boolean | void> = () => Promise.resolve(), onEnd: (id: number) => void = null, prepend = false) {\n  //return;\n  if(elem.querySelector('.c-ripple')) return;\n  elem.classList.add('rp');\n  \n  let r = document.createElement('div');\n  r.classList.add('c-ripple');\n\n  const isSquare = elem.classList.contains('rp-square');\n  if(isSquare) {\n    r.classList.add('is-square');\n  }\n\n  elem[prepend ? 'prepend' : 'append'](r);\n\n  let handler: () => void;\n  //let animationEndPromise: Promise<number>;\n  const drawRipple = (clientX: number, clientY: number) => {\n    const startTime = Date.now();\n    const elem = document.createElement('div');\n\n    const clickId = rippleClickId++;\n    \n    //console.log('ripple drawRipple');\n    \n    const duration = +window.getComputedStyle(r).getPropertyValue('--ripple-duration').replace('s', '') * 1000;\n    //console.log('ripple duration', duration);\n\n    handler = () => {\n    //handler = () => animationEndPromise.then((duration) => {\n      //console.log('ripple animation was:', duration);\n\n      //const duration = isSquare || mediaSizes.isMobile ? 200 : 700;\n      //return;\n      let elapsedTime = Date.now() - startTime;\n      const cb = () => {\n        //console.log('ripple elapsedTime total pre-remove:', Date.now() - startTime);\n        sequentialDom.mutate(() => {\n          elem.remove();\n        });\n        \n        if(onEnd) onEnd(clickId);\n      };\n      if(elapsedTime < duration) {\n        let delay = Math.max(duration - elapsedTime, duration / 2);\n        setTimeout(() => elem.classList.add('hiding'), Math.max(delay - duration / 2, 0));\n\n        setTimeout(cb, delay);\n      } else {\n        elem.classList.add('hiding');\n        setTimeout(cb, duration / 2);\n      }\n\n      if(!isTouchSupported) {\n        window.removeEventListener('contextmenu', handler);\n      }\n\n      handler = null;\n      touchStartFired = false;\n    };\n    //});\n\n    callback && callback(clickId);\n\n    /* callback().then((bad) => {\n      if(bad) {\n        span.remove();\n        return;\n      } */\n      \n      //console.log('ripple after promise', Date.now() - startTime);\n      //console.log('ripple tooSlow:', tooSlow);\n      /* if(tooSlow) {\n        span.remove();\n        return;\n      } */\n\n      window.requestAnimationFrame(() => {\n        const rect = r.getBoundingClientRect();\n        elem.classList.add('c-ripple__circle');\n\n        const clickX = clientX - rect.left;\n        const clickY = clientY - rect.top;\n\n        const radius = Math.sqrt((Math.abs(clickY - rect.height / 2) + rect.height / 2) ** 2 + (Math.abs(clickX - rect.width / 2) + rect.width / 2) ** 2);\n        const size = radius;\n\n        // center of circle\n        const x = clickX - size / 2;\n        const y = clickY - size / 2;\n\n        //console.log('ripple click', offsetFromCenter, size, clickX, clickY);\n\n        elem.style.width = elem.style.height = size + 'px';\n        elem.style.left = x + 'px';\n        elem.style.top = y + 'px';\n\n        // нижний код выполняется с задержкой\n        /* animationEndPromise = new Promise((resolve) => {\n          span.addEventListener('animationend', () => {\n            // 713 -> 700\n            resolve(((Date.now() - startTime) / 100 | 0) * 100);\n          }, {once: true});\n        }); */\n        \n        // нижний код не всегда включает анимацию ПРИ КЛИКЕ НА ТАЧПАД БЕЗ ТАПТИК ЭНЖИНА\n        /* span.style.display = 'none';\n        r.append(span);\n        duration = +window.getComputedStyle(span).getPropertyValue('animation-duration').replace('s', '') * 1000;\n        span.style.display = ''; */\n\n        r.append(elem);\n\n        //r.classList.add('active');\n        //handler();\n      });\n    //});\n  };\n\n  const isRippleUnneeded = (e: Event) => e.target !== elem && (\n      ['BUTTON', 'A'].includes((e.target as HTMLElement).tagName) \n      || findUpClassName(e.target as HTMLElement, 'c-ripple') !== r\n    );\n\n  // TODO: rename this variable\n  let touchStartFired = false;\n  if(isTouchSupported) {\n    let touchEnd = () => {\n      handler && handler();\n    };\n  \n    elem.addEventListener('touchstart', (e) => {\n      if(!rootScope.settings.animationsEnabled) {\n        return;\n      }\n\n      //console.log('ripple touchstart', e);\n      if(e.touches.length > 1 || touchStartFired || isRippleUnneeded(e)) {\n        return;\n      }\n      \n      //console.log('touchstart', e);\n      touchStartFired = true;\n  \n      let {clientX, clientY} = e.touches[0];\n      drawRipple(clientX, clientY);\n      elem.addEventListener('touchend', touchEnd, {once: true});\n  \n      window.addEventListener('touchmove', (e) => {\n        e.cancelBubble = true;\n        e.stopPropagation();\n        touchEnd();\n        elem.removeEventListener('touchend', touchEnd);\n      }, {once: true});\n    }, {passive: true});\n  } else {\n    elem.addEventListener('mousedown', (e) => {\n      if(![0, 2].includes(e.button)) { // only left and right buttons\n        return;\n      }\n\n      if(!rootScope.settings.animationsEnabled) {\n        return;\n      }\n      //console.log('ripple mousedown', e, e.target, findUpClassName(e.target as HTMLElement, 'c-ripple') === r);\n\n      if(elem.dataset.ripple === '0' || isRippleUnneeded(e)) {\n        return;\n      } else if(touchStartFired) {\n        touchStartFired = false;\n        return;\n      }\n  \n      let {clientX, clientY} = e;\n      drawRipple(clientX, clientY);\n      window.addEventListener('mouseup', handler, {once: true, passive: true});\n      window.addEventListener('contextmenu', handler, {once: true, passive: true});\n    }, {passive: true});\n  }\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nexport interface CancellablePromise<T> extends Promise<T> {\n  resolve?: (...args: any[]) => void,\n  reject?: (...args: any[]) => void,\n  cancel?: () => void,\n\n  notify?: (...args: any[]) => void,\n  notifyAll?: (...args: any[]) => void,\n  lastNotify?: any,\n  listeners?: Array<(...args: any[]) => void>,\n  addNotifyListener?: (callback: (...args: any[]) => void) => void,\n\n  isFulfilled?: boolean,\n  isRejected?: boolean\n}\n\nexport function deferredPromise<T>() {\n  let deferredHelper: any = {\n    isFulfilled: false, \n    isRejected: false,\n\n    notify: () => {}, \n    notifyAll: (...args: any[]) => {\n      deferredHelper.lastNotify = args;\n      deferredHelper.listeners.forEach((callback: any) => callback(...args));\n    }, \n\n    lastNotify: undefined,\n    listeners: [],\n    addNotifyListener: (callback: (...args: any[]) => void) => {\n      if(deferredHelper.lastNotify) {\n        callback(...deferredHelper.lastNotify);\n      }\n\n      deferredHelper.listeners.push(callback);\n    }\n  };\n\n  let deferred: CancellablePromise<T> = new Promise<T>((resolve, reject) => {\n    deferredHelper.resolve = (value: T) => {\n      if(deferred.isFulfilled) return;\n\n      deferred.isFulfilled = true;\n      resolve(value);\n    };\n    \n    deferredHelper.reject = (...args: any[]) => {\n      if(deferred.isRejected) return;\n      \n      deferred.isRejected = true;\n      reject(...args);\n    };\n  });\n\n  // @ts-ignore\n  /* deferred.then = (resolve: (value: T) => any, reject: (...args: any[]) => any) => {\n    const n = deferredPromise<ReturnType<typeof resolve>>();\n    \n  }; */\n\n  deferred.finally(() => {\n    deferred.notify = null;\n    deferred.listeners.length = 0;\n    deferred.lastNotify = null;\n\n    if(deferred.cancel) {\n      deferred.cancel = () => {};\n    }\n  });\n\n  Object.assign(deferred, deferredHelper);\n\n  return deferred;\n}","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\n//import { MOUNT_CLASS_TO } from \"../config/debug\";\nimport type { ArgumentTypes, SuperReturnType } from \"../types\";\n\n// class EventSystem {\n//   wm: WeakMap<any, Record<any, Set<any>>> = new WeakMap();\n\n//   add(target: any, event: any, listener: any) {\n//     let listeners = this.wm.get(target);\n//     if (listeners === undefined) {\n//         listeners = {};\n//     }\n//     let listenersForEvent = listeners[event];\n//     if (listenersForEvent === undefined) {\n//         listenersForEvent = new Set();\n//     }\n//     listenersForEvent.add(listener);\n//     listeners[event] = listenersForEvent;\n//     //target.addEventListener(event, listener);\n//     this.wm.set(target, listeners);\n//   };\n\n//   remove(target: any, event: any, listener: any) {\n//     let listeners = this.wm.get(target);\n//     if (!listeners) return;\n//     let listenersForEvent = listeners[event];\n//     if (!listenersForEvent) return;\n//     listenersForEvent.delete(listener);\n//   };\n  \n//   /* fire(target, event) {\n//      let listeners = this.wm.get(target);\n//      if (!listeners) return;\n//      let listenersForEvent = listeners[event];\n//      if (!listenersForEvent) return;\n//      for (let handler of handlers) {\n//          setTimeout(handler, 0, event, target); // we use a setTimeout here because we want event triggering to be asynchronous. \n//      }\n//   }; */\n// }\n\n// console.log = () => {};\n\n// const e = new EventSystem();\n// MOUNT_CLASS_TO.e = e;\n\n/**\n * Better not to remove listeners during setting\n * Should add listener callback only once\n */\nexport default class EventListenerBase<Listeners extends {[name: string]: Function}> {\n  protected listeners: Partial<{\n    [k in keyof Listeners]: Array<{callback: Listeners[k], once?: boolean}>\n  }>;\n  protected listenerResults: Partial<{\n    [k in keyof Listeners]: ArgumentTypes<Listeners[k]>\n  }>;\n\n  private reuseResults: boolean;\n\n  constructor(reuseResults?: boolean) {\n    this._constructor(reuseResults);\n  }\n\n  public _constructor(reuseResults = false): any {\n    this.reuseResults = reuseResults;\n    this.listeners = {};\n    this.listenerResults = {};\n  }\n\n  public addEventListener(name: keyof Listeners, callback: Listeners[typeof name], once?: boolean) {\n    if(this.listenerResults.hasOwnProperty(name)) {\n      callback(...this.listenerResults[name]);\n      \n      if(once) {\n        return;\n      }\n    }\n    \n    (this.listeners[name] ?? (this.listeners[name] = [])).push({callback, once});\n    //e.add(this, name, {callback, once});\n  }\n\n  public addMultipleEventsListeners(obj: {\n    [name in keyof Listeners]?: Listeners[name]\n  }) {\n    for(const i in obj) {\n      this.addEventListener(i, obj[i]);\n    }\n  }\n\n  public removeEventListener(name: keyof Listeners, callback: Listeners[typeof name]) {\n    if(this.listeners[name]) {\n      this.listeners[name].findAndSplice(l => l.callback === callback);\n    }\n    //e.remove(this, name, callback);\n  }\n\n  // * must be protected, but who cares\n  public dispatchEvent(name: keyof Listeners, ...args: ArgumentTypes<Listeners[typeof name]>) {\n    if(this.reuseResults) {\n      this.listenerResults[name] = args;\n    }\n\n    const arr: Array<SuperReturnType<Listeners[typeof name]>> = [];\n\n    /* let a = e.wm.get(this)[name];\n    if(!a) return arr;\n    const listeners = [...a]; */\n    const listeners = this.listeners[name];\n    if(listeners) {\n      // ! this one will guarantee execution even if delete another listener during setting\n      const left = listeners.slice();\n      left.forEach((listener: any) => {\n        const index = listeners.findIndex((l: any) => l.callback === listener.callback);\n        if(index === -1) {\n          return;\n        }\n\n        arr.push(listener.callback(...args));\n\n        if(listener.once) {\n          this.removeEventListener(name, listener.callback);\n        }\n      });\n\n      /* for(let i = 0, length = listeners.length; i < length; ++i) {\n        const listener = listeners[i];\n        arr.push(listener.callback(...args));\n\n        if(listener.once) {\n          listeners.splice(i, 1);\n          --i;\n          --length;\n        }\n      } */\n    }\n\n    return arr;\n  }\n\n  public cleanup() {\n    this.listeners = {}; \n    this.listenerResults = {};\n  }\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n * \n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\n/* export function isInDOM(element: Element, parentNode?: HTMLElement): boolean {\n  if(!element) {\n    return false;\n  }\n\n  parentNode = parentNode || document.body;\n  if(element === parentNode) {\n    return true;\n  }\n  return isInDOM(element.parentNode as HTMLElement, parentNode);\n} */\nexport default function isInDOM(element: Element): boolean {\n  return element?.isConnected;\n}\n","import { fastRaf } from \"./schedulers\";\nimport { CancellablePromise, deferredPromise } from \"./cancellablePromise\";\nimport { MOUNT_CLASS_TO } from \"../config/debug\";\nimport isInDOM from \"./dom/isInDOM\";\n\nclass SequentialDom {\n  private promises: Partial<{\n    read: CancellablePromise<void>,\n    write: CancellablePromise<void>\n  }> = {};\n  private raf = fastRaf.bind(null);\n  private scheduled = false;\n\n  private do(kind: keyof SequentialDom['promises'], callback?: VoidFunction) {\n    let promise = this.promises[kind];\n    if(!promise) {\n      this.scheduleFlush();\n      promise = this.promises[kind] = deferredPromise<void>();\n    }\n\n    if(callback !== undefined) {\n      promise.then(() => callback());\n    }\n    \n    return promise;\n  }\n\n  public measure(callback?: VoidFunction) {\n    return this.do('read', callback);\n  }\n\n  public mutate(callback?: VoidFunction) {\n    return this.do('write', callback);\n  }\n\n  /**\n   * Will fire instantly if element is not connected\n   * @param element \n   * @param callback \n   */\n  public mutateElement(element: HTMLElement, callback?: VoidFunction) {\n    const promise = isInDOM(element) ? this.mutate() : Promise.resolve();\n\n    if(callback !== undefined) {\n      promise.then(() => callback());\n    }\n\n    return promise;\n  }\n\n  private scheduleFlush() {\n    if(!this.scheduled) {\n      this.scheduled = true;\n\n      this.raf(() => {\n        this.promises.read && this.promises.read.resolve();\n        this.promises.write && this.promises.write.resolve();\n\n        this.scheduled = false;\n        this.promises = {};\n      });\n    }\n  }\n}\n\nconst sequentialDom = new SequentialDom();\nMOUNT_CLASS_TO && (MOUNT_CLASS_TO.sequentialDom = sequentialDom);\nexport default sequentialDom;\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n * \n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nconst Modes = {\n  test: location.search.indexOf('test=1') > 0/*  || true */,\n  debug: location.search.indexOf('debug=1') > 0,\n  http: false, //location.search.indexOf('http=1') > 0,\n  ssl: true, // location.search.indexOf('ssl=1') > 0 || location.protocol === 'https:' && location.search.indexOf('ssl=0') === -1,\n  multipleConnections: true,\n  asServiceWorker: false\n};\n\n                  \n                             \n          \n\nexport default Modes;\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport Modes from \"./modes\";\n\nexport const DEBUG = process.env.NODE_ENV !== 'production' || Modes.debug;\nconst ctx: any = typeof(window) !== 'undefined' ? window : self;\nexport const MOUNT_CLASS_TO: any = DEBUG || true/*  && false */ ? ctx : {};\nexport default DEBUG;\n\n//let m = DEBUG;\n/* if(!DEBUG) {\n  ctx.sandpitTurtle = () => {\n    //if(!m) {\n      for(let i in MOUNT_CLASS_TO) {\n        ctx[i] = MOUNT_CLASS_TO[i];\n      }\n      //m = true;\n    //}\n  \n    //DEBUG = !DEBUG;\n  };\n} */\n\n/* export const superDebug = (object: any, key: string) => {\n  var d = object[key];\n  var beforeStr = '', afterStr = '';\n  for(var r of d) {\n    beforeStr += r.before.hex + '\\n';\n    afterStr += r.after.hex + '\\n';\n  }\n\n  beforeStr = beforeStr.trim();\n  afterStr = afterStr.trim();\n  //var beforeStr = d.map(r => r.before.hex).join('\\n');\n  //var afterStr = d.map(r => r.after.hex).join('\\n');\n\n  var dada = (name: string, str: string) => {\n    var a = document.createElement('a');\n    a.target = '_blank';\n    a.download = name + '.txt';\n    a.href = URL.createObjectURL(new Blob([str], {\n      type: 'text/plain'\n    }));\n    document.body.append(a);\n    a.click();\n  };\n\n  dada(key + '_' + 'before', beforeStr);\n  dada(key + '_' + 'after', afterStr);\n}\n\nMOUNT_CLASS_TO.superDebug = superDebug; */\n"],"sourceRoot":""}