{"version":3,"sources":["webpack:///./src/helpers/schedulers.ts","webpack:///./src/helpers/touchSupport.ts","webpack:///./src/components/ripple.ts","webpack:///./src/helpers/cancellablePromise.ts","webpack:///./src/helpers/eventListenerBase.ts","webpack:///./src/helpers/dom/isInDOM.ts","webpack:///./src/helpers/sequentialDom.ts","webpack:///./src/config/modes.ts","webpack:///./src/config/debug.ts","webpack:///./src/lib/rootScope.ts"],"names":["debounce","fn","ms","shouldRunFirst","shouldRunLast","waitingTimeout","args","clearTimeout","setTimeout","throttle","isPending","interval","_args","setInterval","clearInterval","pause","Promise","resolve","fastRafCallbacks","fastRaf","callback","push","requestAnimationFrame","currentCallbacks","undefined","forEach","cb","doubleRaf","isTouchSupported","window","DocumentTouch","document","rippleClickId","ripple","elem","onEnd","prepend","querySelector","classList","add","r","createElement","handler","contains","drawRipple","clientX","clientY","startTime","Date","now","clickId","duration","getComputedStyle","getPropertyValue","replace","elapsedTime","mutate","remove","delay","Math","max","removeEventListener","touchStartFired","rect","getBoundingClientRect","clickX","left","clickY","top","size","sqrt","abs","height","width","x","y","style","append","isRippleUnneeded","e","target","includes","tagName","touchEnd","addEventListener","settings","animationsEnabled","touches","length","once","cancelBubble","stopPropagation","passive","button","dataset","deferredPromise","deferredHelper","isFulfilled","isRejected","notify","notifyAll","lastNotify","listeners","addNotifyListener","deferred","reject","value","finally","cancel","Object","assign","EventListenerBase","reuseResults","this","_constructor","listenerResults","name","hasOwnProperty","obj","i","findAndSplice","l","arr","slice","listener","findIndex","isInDOM","element","isConnected","sequentialDom","promises","raf","bind","scheduled","kind","promise","scheduleFlush","then","do","read","write","Modes","test","location","search","indexOf","debug","http","ssl","multipleConnections","asServiceWorker","DEBUG","MOUNT_CLASS_TO","self","RootScope","super","_overlayIsActive","myId","idle","isIDLE","deactivated","focusPromise","focusResolve","connectionStatus","peerId","broadcast","detail","dispatchEvent","on","off","id","status","darkModeMediaQuery","matchMedia","checkDarkMode","systemTheme","matches","setTheme","addListener","err","isNight","getTheme","colorScheme","head","setAttribute","documentElement","toggle","theme","themes","find","t","rootScope"],"mappings":"4FAWO,SAASA,EACdC,EACAC,EACAC,GAAiB,EACjBC,GAAgB,GAEhB,IAAIC,EAAgC,KAEpC,MAAO,IAAIC,KACND,GACDE,aAAaF,GACbA,EAAiB,MACTF,GAERF,KAAMK,GAGRD,EAAiBG,WAAW,KACvBJ,GAEDH,KAAMK,GAGRD,EAAiB,MAChBH,IAIA,SAASO,EACdR,EACAC,EACAC,GAAiB,GAEjB,IACIO,EACAJ,EAFAK,EAA0B,KAI9B,MAAO,IAAIC,KACTF,GAAY,EACZJ,EAAOM,EAEHD,IACCR,IACDO,GAAY,EAEZT,KAAMK,IAGRK,EAAWE,YAAY,KACrB,IAAKH,EAGH,OAFAI,cAAcH,QACdA,EAAW,MAIbD,GAAY,EAEZT,KAAMK,IACLJ,KArET,0KAiHO,MAAMa,EAASb,GAAe,IAAIc,QAAeC,IACtDT,WAAWS,EAASf,KAGtB,IAAIgB,EACG,SAASC,EAAQC,GAClBF,EASFA,EAAiBG,KAAKD,IARtBF,EAAmB,CAACE,GAEpBE,sBAAsB,KACpB,MAAMC,EAAmBL,EACzBA,OAAmBM,EACnBD,EAAiBE,QAASC,GAAOA,QAOhC,SAASC,IACd,OAAO,IAAIX,QAAeC,IACxBE,EAAQ,KACNA,EAAQF,S,gCCvId,wDAOO,MAAMW,EAAoB,iBAAkBC,QAAYA,OAAOC,eAAiBC,oBAAoBD,e,gCCP3G,gFAWA,IAAIE,EAAgB,EACb,SAASC,EAAOC,EAAmBd,EAAoD,KAAMJ,QAAQC,WAAWkB,EAA8B,KAAMC,GAAU,GAEnK,GAAGF,EAAKG,cAAc,aAAc,OACpCH,EAAKI,UAAUC,IAAI,MAEnB,IAAIC,EAAIT,SAASU,cAAc,OAC/BD,EAAEF,UAAUC,IAAI,YAShB,IAAIG,EAPaR,EAAKI,UAAUK,SAAS,cAEvCH,EAAEF,UAAUC,IAAI,aAGlBL,EAAKE,EAAU,UAAY,UAAUI,GAIrC,MAAMI,EAAa,CAACC,EAAiBC,KACnC,MAAMC,EAAYC,KAAKC,MACjBf,EAAOH,SAASU,cAAc,OAE9BS,EAAUlB,IAIVmB,EAAgG,KAApFtB,OAAOuB,iBAAiBZ,GAAGa,iBAAiB,qBAAqBC,QAAQ,IAAK,IAGhGZ,EAAU,KAMR,IAAIa,EAAcP,KAAKC,MAAQF,EAC/B,MAAMrB,EAAK,KAET,IAAc8B,OAAO,KACnBtB,EAAKuB,WAGJtB,GAAOA,EAAMe,IAElB,GAAGK,EAAcJ,EAAU,CACzB,IAAIO,EAAQC,KAAKC,IAAIT,EAAWI,EAAaJ,EAAW,GACxD3C,WAAW,IAAM0B,EAAKI,UAAUC,IAAI,UAAWoB,KAAKC,IAAIF,EAAQP,EAAW,EAAG,IAE9E3C,WAAWkB,EAAIgC,QAEfxB,EAAKI,UAAUC,IAAI,UACnB/B,WAAWkB,EAAIyB,EAAW,GAGxB,oBACFtB,OAAOgC,oBAAoB,cAAenB,GAG5CA,EAAU,KACVoB,GAAkB,GAIpB1C,GAAYA,EAAS8B,GAenBrB,OAAOP,sBAAsB,KAC3B,MAAMyC,EAAOvB,EAAEwB,wBACf9B,EAAKI,UAAUC,IAAI,oBAEnB,MAAM0B,EAASpB,EAAUkB,EAAKG,KACxBC,EAASrB,EAAUiB,EAAKK,IAGxBC,EADSV,KAAKW,KAAK,SAACX,KAAKY,IAAIJ,EAASJ,EAAKS,OAAS,GAAKT,EAAKS,OAAS,EAAM,GAAI,SAACb,KAAKY,IAAIN,EAASF,EAAKU,MAAQ,GAAKV,EAAKU,MAAQ,EAAM,IAIzIC,EAAIT,EAASI,EAAO,EACpBM,EAAIR,EAASE,EAAO,EAI1BnC,EAAK0C,MAAMH,MAAQvC,EAAK0C,MAAMJ,OAASH,EAAO,KAC9CnC,EAAK0C,MAAMV,KAAOQ,EAAI,KACtBxC,EAAK0C,MAAMR,IAAMO,EAAI,KAgBrBnC,EAAEqC,OAAO3C,MAQT4C,EAAoBC,GAAaA,EAAEC,SAAW9C,IAChD,CAAC,SAAU,KAAK+C,SAAUF,EAAEC,OAAuBE,UAChD,YAAgBH,EAAEC,OAAuB,cAAgBxC,GAIhE,IAAIsB,GAAkB,EACtB,GAAG,mBAAkB,CACnB,IAAIqB,EAAW,KACbzC,GAAWA,KAGbR,EAAKkD,iBAAiB,aAAeL,IACnC,IAAI,UAAUM,SAASC,kBACrB,OAIF,GAAGP,EAAEQ,QAAQC,OAAS,GAAK1B,GAAmBgB,EAAiBC,GAC7D,OAIFjB,GAAkB,EAElB,IAAI,QAACjB,EAAO,QAAEC,GAAWiC,EAAEQ,QAAQ,GACnC3C,EAAWC,EAASC,GACpBZ,EAAKkD,iBAAiB,WAAYD,EAAU,CAACM,MAAM,IAEnD5D,OAAOuD,iBAAiB,YAAcL,IACpCA,EAAEW,cAAe,EACjBX,EAAEY,kBACFR,IACAjD,EAAK2B,oBAAoB,WAAYsB,IACpC,CAACM,MAAM,KACT,CAACG,SAAS,SAEb1D,EAAKkD,iBAAiB,YAAcL,IAClC,IAAI,CAAC,EAAG,GAAGE,SAASF,EAAEc,QACpB,OAGF,IAAI,UAAUR,SAASC,kBACrB,OAIF,GAA2B,MAAxBpD,EAAK4D,QAAQ7D,QAAkB6C,EAAiBC,GACjD,OACK,GAAGjB,EAER,YADAA,GAAkB,GAIpB,IAAI,QAACjB,EAAO,QAAEC,GAAWiC,EACzBnC,EAAWC,EAASC,GACpBjB,OAAOuD,iBAAiB,UAAW1C,EAAS,CAAC+C,MAAM,EAAMG,SAAS,IAClE/D,OAAOuD,iBAAiB,cAAe1C,EAAS,CAAC+C,MAAM,EAAMG,SAAS,KACrE,CAACA,SAAS,M,gCCxKV,SAASG,IACd,IAAIC,EAAsB,CACxBC,aAAa,EACbC,YAAY,EAEZC,OAAQ,OACRC,UAAW,IAAI9F,KACb0F,EAAeK,WAAa/F,EAC5B0F,EAAeM,UAAU7E,QAASL,GAAkBA,KAAYd,KAGlE+F,gBAAY7E,EACZ8E,UAAW,GACXC,kBAAoBnF,IACf4E,EAAeK,YAChBjF,KAAY4E,EAAeK,YAG7BL,EAAeM,UAAUjF,KAAKD,KAI9BoF,EAAkC,IAAIxF,QAAW,CAACC,EAASwF,KAC7DT,EAAe/E,QAAWyF,IACrBF,EAASP,cAEZO,EAASP,aAAc,EACvBhF,EAAQyF,KAGVV,EAAeS,OAAS,IAAInG,KACvBkG,EAASN,aAEZM,EAASN,YAAa,EACtBO,KAAUnG,OAsBd,OAZAkG,EAASG,QAAQ,KACfH,EAASL,OAAS,KAClBK,EAASF,UAAUd,OAAS,EAC5BgB,EAASH,WAAa,KAEnBG,EAASI,SACVJ,EAASI,OAAS,UAItBC,OAAOC,OAAON,EAAUR,GAEjBQ,EA7ET,mC,gCCAA,kCAuDe,MAAMO,EAUnB,YAAYC,GACVC,KAAKC,aAAaF,GAGb,aAAaA,GAAe,GACjCC,KAAKD,aAAeA,EACpBC,KAAKX,UAAY,GACjBW,KAAKE,gBAAkB,GAGlB,iBAAiBC,EAAuBhG,EAAkCqE,G,MAC5EwB,KAAKE,gBAAgBE,eAAeD,KACrChG,KAAY6F,KAAKE,gBAAgBC,IAE9B3B,KAKgB,QAApB,EAAAwB,KAAKX,UAAUc,UAAK,QAAKH,KAAKX,UAAUc,GAAQ,IAAK/F,KAAK,CAACD,WAAUqE,SAIjE,2BAA2B6B,GAGhC,IAAI,MAAMC,KAAKD,EACbL,KAAK7B,iBAAiBmC,EAAGD,EAAIC,IAI1B,oBAAoBH,EAAuBhG,GAC7C6F,KAAKX,UAAUc,IAChBH,KAAKX,UAAUc,GAAMI,cAAcC,GAAKA,EAAErG,WAAaA,GAMpD,cAAcgG,KAA0B9G,GAC1C2G,KAAKD,eACNC,KAAKE,gBAAgBC,GAAQ9G,GAG/B,MAAMoH,EAAsD,GAKtDpB,EAAYW,KAAKX,UAAUc,GACjC,GAAGd,EAAW,CAECA,EAAUqB,QAClBlG,QAASmG,KAEE,IADAtB,EAAUuB,UAAWJ,GAAWA,EAAErG,WAAawG,EAASxG,YAKtEsG,EAAIrG,KAAKuG,EAASxG,YAAYd,IAE3BsH,EAASnC,MACVwB,KAAKpD,oBAAoBuD,EAAMQ,EAASxG,aAgB9C,OAAOsG,EAGF,UACLT,KAAKX,UAAY,GACjBW,KAAKE,gBAAkB,M,gCC9HZ,SAASW,EAAQC,GAC9B,OAAOA,aAAO,EAAPA,EAASC,YAvBlB,mC,gCCAA,mCAiEA,MAAMC,EAAgB,IA5DtB,oBACU,KAAAC,SAGH,GACG,KAAAC,IAAM,IAAQC,KAAK,MACnB,KAAAC,WAAY,EAEZ,GAAGC,EAAuClH,GAChD,IAAImH,EAAUtB,KAAKiB,SAASI,GAU5B,OATIC,IACFtB,KAAKuB,gBACLD,EAAUtB,KAAKiB,SAASI,GAAQ,oBAGlB9G,IAAbJ,GACDmH,EAAQE,KAAK,IAAMrH,KAGdmH,EAGF,QAAQnH,GACb,OAAO6F,KAAKyB,GAAG,OAAQtH,GAGlB,OAAOA,GACZ,OAAO6F,KAAKyB,GAAG,QAAStH,GAQnB,cAAc2G,EAAsB3G,GACzC,MAAMmH,EAAU,YAAQR,GAAWd,KAAKzD,SAAWxC,QAAQC,UAM3D,YAJgBO,IAAbJ,GACDmH,EAAQE,KAAK,IAAMrH,KAGdmH,EAGD,gBACFtB,KAAKoB,YACPpB,KAAKoB,WAAY,EAEjBpB,KAAKkB,IAAI,KACPlB,KAAKiB,SAASS,MAAQ1B,KAAKiB,SAASS,KAAK1H,UACzCgG,KAAKiB,SAASU,OAAS3B,KAAKiB,SAASU,MAAM3H,UAE3CgG,KAAKoB,WAAY,EACjBpB,KAAKiB,SAAW,QAOxB,MAAmB,IAAeD,cAAgBA,GACnC,O,gCCxDf,MAAMY,EAAQ,CACZC,KAAMC,SAASC,OAAOC,QAAQ,UAAY,EAC1CC,MAAOH,SAASC,OAAOC,QAAQ,WAAa,EAC5CE,MAAM,EACNC,KAAK,EACLC,qBAAqB,EACrBC,iBAAiB,GAOJ,O,+BCxBf,kCAQO,MAAMC,EARb,MAQ8D,EAAML,MAEvDM,EADuB,oBAAb,OAA2B3H,OAAS4H,KAE5C,O,+BCXf,oEAqHO,MAAMC,UAAkB,IAkB7B,cACEC,QAdM,KAAAC,kBAA4B,EAC7B,KAAAC,KAAO,EACP,KAAAC,KAAO,CACZC,QAAQ,EACRC,aAAa,EACbC,aAAcjJ,QAAQC,UACtBiJ,aAAc,QAET,KAAAC,iBAA6D,GAE7D,KAAAC,OAAS,EAgFT,KAAAC,UAAY,CAAkCjD,EAASkD,KAO5DrD,KAAKsD,cAAcnD,EAAMkD,IAGpB,KAAAE,GAAK,CAAkCpD,EAAShG,EAA0CqE,KAC/FkE,MAAMvE,iBAAiBgC,EAAMhG,EAAUqE,IAGlC,KAAAL,iBAAmB6B,KAAKuD,GAExB,KAAAC,IAAM,CAAkCrD,EAAShG,KACtDuI,MAAM9F,oBAAoBuD,EAAMhG,IAG3B,KAAAyC,oBAAsBoD,KAAKwD,IA9FhCxD,KAAKuD,GAAG,eAAiBJ,IACvBnD,KAAKmD,OAASA,IAGhBnD,KAAKuD,GAAG,YAAczF,IACpBkC,KAAK4C,KAAO9E,EAAE2F,KAGhBzD,KAAKuD,GAAG,2BAA6BzF,IACnC,MAAM4F,EAAS5F,EACfkC,KAAKkD,iBAAiBpF,EAAEqC,MAAQuD,IAGlC1D,KAAKuD,GAAG,OAAST,IACZA,EACD9C,KAAK6C,KAAKG,aAAe,IAAIjJ,QAASC,IACpCgG,KAAK6C,KAAKI,aAAejJ,IAG3BgG,KAAK6C,KAAKI,iBAKT,mBACL,IACE,MAAMU,EAAqB/I,OAAOgJ,WAAW,gCACvCC,EAAgB,KAEpB7D,KAAK8D,YAAcH,EAAmBI,QAAU,QAAU,MAGvD/D,KAAK4C,KACN5C,KAAKoD,UAAU,gBAEfpD,KAAKgE,YAIN,qBAAsBL,EACvBA,EAAmBxF,iBAAiB,SAAU0F,GACtC,gBAAiBF,GACxBA,EAA2BM,YAAYJ,GAG1CA,IACA,MAAMK,KAKH,WACL,MAAMC,EAAmC,UAAzBnE,KAAKoE,WAAWjE,KAC1BkE,EAAcvJ,SAASwJ,KAAKlJ,cAAc,yBAC7CiJ,GACDA,EAAYE,aAAa,UAAWJ,EAAU,OAAS,SAGzDrJ,SAAS0J,gBAAgBnJ,UAAUoJ,OAAO,QAASN,GAGrD,sBACE,OAAOnE,KAAK2C,iBAGd,oBAAoBlD,GAClBO,KAAK2C,iBAAmBlD,EACxBO,KAAKoD,UAAU,iBAAkB3D,GAG5B,SAASU,GAA8C,WAAxBH,KAAK5B,SAASsG,MAAqB1E,KAAK8D,YAAc9D,KAAK5B,SAASsG,QACxG,OAAO1E,KAAK5B,SAASuG,OAAOC,KAAKC,GAAKA,EAAE1E,OAASA,IA0BrD,MAAM2E,EAAY,IAAIrC,EACtB,IAAeqC,UAAYA,EACZ","file":"15.8e1e172f4378c3463f28.chunk.js","sourcesContent":["/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\n// * Jolly Cobra's schedulers\r\nimport { AnyToVoidFunction, NoneToVoidFunction } from \"../types\";\r\n\r\n//type Scheduler = typeof requestAnimationFrame | typeof onTickEnd | typeof runNow;\r\n\r\nexport function debounce<F extends AnyToVoidFunction>(\r\n  fn: F,\r\n  ms: number,\r\n  shouldRunFirst = true,\r\n  shouldRunLast = true,\r\n) {\r\n  let waitingTimeout: number | null = null;\r\n\r\n  return (...args: Parameters<F>) => {\r\n    if(waitingTimeout) {\r\n      clearTimeout(waitingTimeout);\r\n      waitingTimeout = null;\r\n    } else if(shouldRunFirst) {\r\n      // @ts-ignore\r\n      fn(...args);\r\n    }\r\n\r\n    waitingTimeout = setTimeout(() => {\r\n      if(shouldRunLast) {\r\n        // @ts-ignore\r\n        fn(...args);\r\n      }\r\n\r\n      waitingTimeout = null;\r\n    }, ms) as any;\r\n  };\r\n}\r\n\r\nexport function throttle<F extends AnyToVoidFunction>(\r\n  fn: F,\r\n  ms: number,\r\n  shouldRunFirst = true,\r\n) {\r\n  let interval: number | null = null;\r\n  let isPending: boolean;\r\n  let args: Parameters<F>;\r\n\r\n  return (..._args: Parameters<F>) => {\r\n    isPending = true;\r\n    args = _args;\r\n\r\n    if(!interval) {\r\n      if(shouldRunFirst) {\r\n        isPending = false;\r\n        // @ts-ignore\r\n        fn(...args);\r\n      }\r\n\r\n      interval = setInterval(() => {\r\n        if (!isPending) {\r\n          clearInterval(interval!);\r\n          interval = null;\r\n          return;\r\n        }\r\n\r\n        isPending = false;\r\n        // @ts-ignore\r\n        fn(...args);\r\n      }, ms) as any;\r\n    }\r\n  };\r\n}\r\n\r\n/* export function throttleWithRaf<F extends AnyToVoidFunction>(fn: F) {\r\n  return throttleWith(fastRaf, fn);\r\n}\r\n\r\nexport function throttleWithTickEnd<F extends AnyToVoidFunction>(fn: F) {\r\n  return throttleWith(onTickEnd, fn);\r\n}\r\n\r\nexport function throttleWithNow<F extends AnyToVoidFunction>(fn: F) {\r\n  return throttleWith(runNow, fn);\r\n}\r\n\r\nexport function throttleWith<F extends AnyToVoidFunction>(schedulerFn: Scheduler, fn: F) {\r\n  let waiting = false;\r\n  let args: Parameters<F>;\r\n\r\n  return (..._args: Parameters<F>) => {\r\n    args = _args;\r\n\r\n    if (!waiting) {\r\n      waiting = true;\r\n\r\n      schedulerFn(() => {\r\n        waiting = false;\r\n        // @ts-ignore\r\n        fn(...args);\r\n      });\r\n    }\r\n  };\r\n}\r\n\r\nexport function onTickEnd(cb: NoneToVoidFunction) {\r\n  Promise.resolve().then(cb);\r\n}\r\n\r\nfunction runNow(fn: NoneToVoidFunction) {\r\n  fn();\r\n} */\r\n\r\nexport const pause = (ms: number) => new Promise<void>((resolve) => {\r\n  setTimeout(resolve, ms);\r\n});\r\n\r\nlet fastRafCallbacks: NoneToVoidFunction[] | undefined;\r\nexport function fastRaf(callback: NoneToVoidFunction) {\r\n  if(!fastRafCallbacks) {\r\n    fastRafCallbacks = [callback];\r\n\r\n    requestAnimationFrame(() => {\r\n      const currentCallbacks = fastRafCallbacks!;\r\n      fastRafCallbacks = undefined;\r\n      currentCallbacks.forEach((cb) => cb());\r\n    });\r\n  } else {\r\n    fastRafCallbacks.push(callback);\r\n  }\r\n}\r\n\r\nexport function doubleRaf() {\r\n  return new Promise<void>((resolve) => {\r\n    fastRaf(() => {\r\n      fastRaf(resolve);\r\n    });\r\n  });\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\n// @ts-ignore\r\nexport const isTouchSupported = ('ontouchstart' in window) || (window.DocumentTouch && document instanceof DocumentTouch)/*  || true */;","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport findUpClassName from \"../helpers/dom/findUpClassName\";\r\nimport sequentialDom from \"../helpers/sequentialDom\";\r\nimport {isTouchSupported} from \"../helpers/touchSupport\";\r\nimport rootScope from \"../lib/rootScope\";\r\n\r\nlet rippleClickId = 0;\r\nexport function ripple(elem: HTMLElement, callback: (id: number) => Promise<boolean | void> = () => Promise.resolve(), onEnd: (id: number) => void = null, prepend = false) {\r\n  //return;\r\n  if(elem.querySelector('.c-ripple')) return;\r\n  elem.classList.add('rp');\r\n  \r\n  let r = document.createElement('div');\r\n  r.classList.add('c-ripple');\r\n\r\n  const isSquare = elem.classList.contains('rp-square');\r\n  if(isSquare) {\r\n    r.classList.add('is-square');\r\n  }\r\n\r\n  elem[prepend ? 'prepend' : 'append'](r);\r\n\r\n  let handler: () => void;\r\n  //let animationEndPromise: Promise<number>;\r\n  const drawRipple = (clientX: number, clientY: number) => {\r\n    const startTime = Date.now();\r\n    const elem = document.createElement('div');\r\n\r\n    const clickId = rippleClickId++;\r\n    \r\n    //console.log('ripple drawRipple');\r\n    \r\n    const duration = +window.getComputedStyle(r).getPropertyValue('--ripple-duration').replace('s', '') * 1000;\r\n    //console.log('ripple duration', duration);\r\n\r\n    handler = () => {\r\n    //handler = () => animationEndPromise.then((duration) => {\r\n      //console.log('ripple animation was:', duration);\r\n\r\n      //const duration = isSquare || mediaSizes.isMobile ? 200 : 700;\r\n      //return;\r\n      let elapsedTime = Date.now() - startTime;\r\n      const cb = () => {\r\n        //console.log('ripple elapsedTime total pre-remove:', Date.now() - startTime);\r\n        sequentialDom.mutate(() => {\r\n          elem.remove();\r\n        });\r\n        \r\n        if(onEnd) onEnd(clickId);\r\n      };\r\n      if(elapsedTime < duration) {\r\n        let delay = Math.max(duration - elapsedTime, duration / 2);\r\n        setTimeout(() => elem.classList.add('hiding'), Math.max(delay - duration / 2, 0));\r\n\r\n        setTimeout(cb, delay);\r\n      } else {\r\n        elem.classList.add('hiding');\r\n        setTimeout(cb, duration / 2);\r\n      }\r\n\r\n      if(!isTouchSupported) {\r\n        window.removeEventListener('contextmenu', handler);\r\n      }\r\n\r\n      handler = null;\r\n      touchStartFired = false;\r\n    };\r\n    //});\r\n\r\n    callback && callback(clickId);\r\n\r\n    /* callback().then((bad) => {\r\n      if(bad) {\r\n        span.remove();\r\n        return;\r\n      } */\r\n      \r\n      //console.log('ripple after promise', Date.now() - startTime);\r\n      //console.log('ripple tooSlow:', tooSlow);\r\n      /* if(tooSlow) {\r\n        span.remove();\r\n        return;\r\n      } */\r\n\r\n      window.requestAnimationFrame(() => {\r\n        const rect = r.getBoundingClientRect();\r\n        elem.classList.add('c-ripple__circle');\r\n\r\n        const clickX = clientX - rect.left;\r\n        const clickY = clientY - rect.top;\r\n\r\n        const radius = Math.sqrt((Math.abs(clickY - rect.height / 2) + rect.height / 2) ** 2 + (Math.abs(clickX - rect.width / 2) + rect.width / 2) ** 2);\r\n        const size = radius;\r\n\r\n        // center of circle\r\n        const x = clickX - size / 2;\r\n        const y = clickY - size / 2;\r\n\r\n        //console.log('ripple click', offsetFromCenter, size, clickX, clickY);\r\n\r\n        elem.style.width = elem.style.height = size + 'px';\r\n        elem.style.left = x + 'px';\r\n        elem.style.top = y + 'px';\r\n\r\n        // нижний код выполняется с задержкой\r\n        /* animationEndPromise = new Promise((resolve) => {\r\n          span.addEventListener('animationend', () => {\r\n            // 713 -> 700\r\n            resolve(((Date.now() - startTime) / 100 | 0) * 100);\r\n          }, {once: true});\r\n        }); */\r\n        \r\n        // нижний код не всегда включает анимацию ПРИ КЛИКЕ НА ТАЧПАД БЕЗ ТАПТИК ЭНЖИНА\r\n        /* span.style.display = 'none';\r\n        r.append(span);\r\n        duration = +window.getComputedStyle(span).getPropertyValue('animation-duration').replace('s', '') * 1000;\r\n        span.style.display = ''; */\r\n\r\n        r.append(elem);\r\n\r\n        //r.classList.add('active');\r\n        //handler();\r\n      });\r\n    //});\r\n  };\r\n\r\n  const isRippleUnneeded = (e: Event) => e.target !== elem && (\r\n      ['BUTTON', 'A'].includes((e.target as HTMLElement).tagName) \r\n      || findUpClassName(e.target as HTMLElement, 'c-ripple') !== r\r\n    );\r\n\r\n  // TODO: rename this variable\r\n  let touchStartFired = false;\r\n  if(isTouchSupported) {\r\n    let touchEnd = () => {\r\n      handler && handler();\r\n    };\r\n  \r\n    elem.addEventListener('touchstart', (e) => {\r\n      if(!rootScope.settings.animationsEnabled) {\r\n        return;\r\n      }\r\n\r\n      //console.log('ripple touchstart', e);\r\n      if(e.touches.length > 1 || touchStartFired || isRippleUnneeded(e)) {\r\n        return;\r\n      }\r\n      \r\n      //console.log('touchstart', e);\r\n      touchStartFired = true;\r\n  \r\n      let {clientX, clientY} = e.touches[0];\r\n      drawRipple(clientX, clientY);\r\n      elem.addEventListener('touchend', touchEnd, {once: true});\r\n  \r\n      window.addEventListener('touchmove', (e) => {\r\n        e.cancelBubble = true;\r\n        e.stopPropagation();\r\n        touchEnd();\r\n        elem.removeEventListener('touchend', touchEnd);\r\n      }, {once: true});\r\n    }, {passive: true});\r\n  } else {\r\n    elem.addEventListener('mousedown', (e) => {\r\n      if(![0, 2].includes(e.button)) { // only left and right buttons\r\n        return;\r\n      }\r\n\r\n      if(!rootScope.settings.animationsEnabled) {\r\n        return;\r\n      }\r\n      //console.log('ripple mousedown', e, e.target, findUpClassName(e.target as HTMLElement, 'c-ripple') === r);\r\n\r\n      if(elem.dataset.ripple === '0' || isRippleUnneeded(e)) {\r\n        return;\r\n      } else if(touchStartFired) {\r\n        touchStartFired = false;\r\n        return;\r\n      }\r\n  \r\n      let {clientX, clientY} = e;\r\n      drawRipple(clientX, clientY);\r\n      window.addEventListener('mouseup', handler, {once: true, passive: true});\r\n      window.addEventListener('contextmenu', handler, {once: true, passive: true});\r\n    }, {passive: true});\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nexport interface CancellablePromise<T> extends Promise<T> {\r\n  resolve?: (...args: any[]) => void,\r\n  reject?: (...args: any[]) => void,\r\n  cancel?: () => void,\r\n\r\n  notify?: (...args: any[]) => void,\r\n  notifyAll?: (...args: any[]) => void,\r\n  lastNotify?: any,\r\n  listeners?: Array<(...args: any[]) => void>,\r\n  addNotifyListener?: (callback: (...args: any[]) => void) => void,\r\n\r\n  isFulfilled?: boolean,\r\n  isRejected?: boolean\r\n}\r\n\r\nexport function deferredPromise<T>() {\r\n  let deferredHelper: any = {\r\n    isFulfilled: false, \r\n    isRejected: false,\r\n\r\n    notify: () => {}, \r\n    notifyAll: (...args: any[]) => {\r\n      deferredHelper.lastNotify = args;\r\n      deferredHelper.listeners.forEach((callback: any) => callback(...args));\r\n    }, \r\n\r\n    lastNotify: undefined,\r\n    listeners: [],\r\n    addNotifyListener: (callback: (...args: any[]) => void) => {\r\n      if(deferredHelper.lastNotify) {\r\n        callback(...deferredHelper.lastNotify);\r\n      }\r\n\r\n      deferredHelper.listeners.push(callback);\r\n    }\r\n  };\r\n\r\n  let deferred: CancellablePromise<T> = new Promise<T>((resolve, reject) => {\r\n    deferredHelper.resolve = (value: T) => {\r\n      if(deferred.isFulfilled) return;\r\n\r\n      deferred.isFulfilled = true;\r\n      resolve(value);\r\n    };\r\n    \r\n    deferredHelper.reject = (...args: any[]) => {\r\n      if(deferred.isRejected) return;\r\n      \r\n      deferred.isRejected = true;\r\n      reject(...args);\r\n    };\r\n  });\r\n\r\n  // @ts-ignore\r\n  /* deferred.then = (resolve: (value: T) => any, reject: (...args: any[]) => any) => {\r\n    const n = deferredPromise<ReturnType<typeof resolve>>();\r\n    \r\n  }; */\r\n\r\n  deferred.finally(() => {\r\n    deferred.notify = null;\r\n    deferred.listeners.length = 0;\r\n    deferred.lastNotify = null;\r\n\r\n    if(deferred.cancel) {\r\n      deferred.cancel = () => {};\r\n    }\r\n  });\r\n\r\n  Object.assign(deferred, deferredHelper);\r\n\r\n  return deferred;\r\n}","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\n//import { MOUNT_CLASS_TO } from \"../config/debug\";\r\nimport type { ArgumentTypes, SuperReturnType } from \"../types\";\r\n\r\n// class EventSystem {\r\n//   wm: WeakMap<any, Record<any, Set<any>>> = new WeakMap();\r\n\r\n//   add(target: any, event: any, listener: any) {\r\n//     let listeners = this.wm.get(target);\r\n//     if (listeners === undefined) {\r\n//         listeners = {};\r\n//     }\r\n//     let listenersForEvent = listeners[event];\r\n//     if (listenersForEvent === undefined) {\r\n//         listenersForEvent = new Set();\r\n//     }\r\n//     listenersForEvent.add(listener);\r\n//     listeners[event] = listenersForEvent;\r\n//     //target.addEventListener(event, listener);\r\n//     this.wm.set(target, listeners);\r\n//   };\r\n\r\n//   remove(target: any, event: any, listener: any) {\r\n//     let listeners = this.wm.get(target);\r\n//     if (!listeners) return;\r\n//     let listenersForEvent = listeners[event];\r\n//     if (!listenersForEvent) return;\r\n//     listenersForEvent.delete(listener);\r\n//   };\r\n  \r\n//   /* fire(target, event) {\r\n//      let listeners = this.wm.get(target);\r\n//      if (!listeners) return;\r\n//      let listenersForEvent = listeners[event];\r\n//      if (!listenersForEvent) return;\r\n//      for (let handler of handlers) {\r\n//          setTimeout(handler, 0, event, target); // we use a setTimeout here because we want event triggering to be asynchronous. \r\n//      }\r\n//   }; */\r\n// }\r\n\r\n// console.log = () => {};\r\n\r\n// const e = new EventSystem();\r\n// MOUNT_CLASS_TO.e = e;\r\n\r\n/**\r\n * Better not to remove listeners during setting\r\n * Should add listener callback only once\r\n */\r\nexport default class EventListenerBase<Listeners extends {[name: string]: Function}> {\r\n  protected listeners: Partial<{\r\n    [k in keyof Listeners]: Array<{callback: Listeners[k], once?: boolean}>\r\n  }>;\r\n  protected listenerResults: Partial<{\r\n    [k in keyof Listeners]: ArgumentTypes<Listeners[k]>\r\n  }>;\r\n\r\n  private reuseResults: boolean;\r\n\r\n  constructor(reuseResults?: boolean) {\r\n    this._constructor(reuseResults);\r\n  }\r\n\r\n  public _constructor(reuseResults = false): any {\r\n    this.reuseResults = reuseResults;\r\n    this.listeners = {};\r\n    this.listenerResults = {};\r\n  }\r\n\r\n  public addEventListener(name: keyof Listeners, callback: Listeners[typeof name], once?: boolean) {\r\n    if(this.listenerResults.hasOwnProperty(name)) {\r\n      callback(...this.listenerResults[name]);\r\n      \r\n      if(once) {\r\n        return;\r\n      }\r\n    }\r\n    \r\n    (this.listeners[name] ?? (this.listeners[name] = [])).push({callback, once});\r\n    //e.add(this, name, {callback, once});\r\n  }\r\n\r\n  public addMultipleEventsListeners(obj: {\r\n    [name in keyof Listeners]?: Listeners[name]\r\n  }) {\r\n    for(const i in obj) {\r\n      this.addEventListener(i, obj[i]);\r\n    }\r\n  }\r\n\r\n  public removeEventListener(name: keyof Listeners, callback: Listeners[typeof name]) {\r\n    if(this.listeners[name]) {\r\n      this.listeners[name].findAndSplice(l => l.callback === callback);\r\n    }\r\n    //e.remove(this, name, callback);\r\n  }\r\n\r\n  // * must be protected, but who cares\r\n  public dispatchEvent(name: keyof Listeners, ...args: ArgumentTypes<Listeners[typeof name]>) {\r\n    if(this.reuseResults) {\r\n      this.listenerResults[name] = args;\r\n    }\r\n\r\n    const arr: Array<SuperReturnType<Listeners[typeof name]>> = [];\r\n\r\n    /* let a = e.wm.get(this)[name];\r\n    if(!a) return arr;\r\n    const listeners = [...a]; */\r\n    const listeners = this.listeners[name];\r\n    if(listeners) {\r\n      // ! this one will guarantee execution even if delete another listener during setting\r\n      const left = listeners.slice();\r\n      left.forEach((listener: any) => {\r\n        const index = listeners.findIndex((l: any) => l.callback === listener.callback);\r\n        if(index === -1) {\r\n          return;\r\n        }\r\n\r\n        arr.push(listener.callback(...args));\r\n\r\n        if(listener.once) {\r\n          this.removeEventListener(name, listener.callback);\r\n        }\r\n      });\r\n\r\n      /* for(let i = 0, length = listeners.length; i < length; ++i) {\r\n        const listener = listeners[i];\r\n        arr.push(listener.callback(...args));\r\n\r\n        if(listener.once) {\r\n          listeners.splice(i, 1);\r\n          --i;\r\n          --length;\r\n        }\r\n      } */\r\n    }\r\n\r\n    return arr;\r\n  }\r\n\r\n  public cleanup() {\r\n    this.listeners = {}; \r\n    this.listenerResults = {};\r\n  }\r\n}\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\n/* export function isInDOM(element: Element, parentNode?: HTMLElement): boolean {\r\n  if(!element) {\r\n    return false;\r\n  }\r\n\r\n  parentNode = parentNode || document.body;\r\n  if(element === parentNode) {\r\n    return true;\r\n  }\r\n  return isInDOM(element.parentNode as HTMLElement, parentNode);\r\n} */\r\nexport default function isInDOM(element: Element): boolean {\r\n  return element?.isConnected;\r\n}\r\n","import { fastRaf } from \"./schedulers\";\r\nimport { CancellablePromise, deferredPromise } from \"./cancellablePromise\";\r\nimport { MOUNT_CLASS_TO } from \"../config/debug\";\r\nimport isInDOM from \"./dom/isInDOM\";\r\n\r\nclass SequentialDom {\r\n  private promises: Partial<{\r\n    read: CancellablePromise<void>,\r\n    write: CancellablePromise<void>\r\n  }> = {};\r\n  private raf = fastRaf.bind(null);\r\n  private scheduled = false;\r\n\r\n  private do(kind: keyof SequentialDom['promises'], callback?: VoidFunction) {\r\n    let promise = this.promises[kind];\r\n    if(!promise) {\r\n      this.scheduleFlush();\r\n      promise = this.promises[kind] = deferredPromise<void>();\r\n    }\r\n\r\n    if(callback !== undefined) {\r\n      promise.then(() => callback());\r\n    }\r\n    \r\n    return promise;\r\n  }\r\n\r\n  public measure(callback?: VoidFunction) {\r\n    return this.do('read', callback);\r\n  }\r\n\r\n  public mutate(callback?: VoidFunction) {\r\n    return this.do('write', callback);\r\n  }\r\n\r\n  /**\r\n   * Will fire instantly if element is not connected\r\n   * @param element \r\n   * @param callback \r\n   */\r\n  public mutateElement(element: HTMLElement, callback?: VoidFunction) {\r\n    const promise = isInDOM(element) ? this.mutate() : Promise.resolve();\r\n\r\n    if(callback !== undefined) {\r\n      promise.then(() => callback());\r\n    }\r\n\r\n    return promise;\r\n  }\r\n\r\n  private scheduleFlush() {\r\n    if(!this.scheduled) {\r\n      this.scheduled = true;\r\n\r\n      this.raf(() => {\r\n        this.promises.read && this.promises.read.resolve();\r\n        this.promises.write && this.promises.write.resolve();\r\n\r\n        this.scheduled = false;\r\n        this.promises = {};\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nconst sequentialDom = new SequentialDom();\r\nMOUNT_CLASS_TO && (MOUNT_CLASS_TO.sequentialDom = sequentialDom);\r\nexport default sequentialDom;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nconst Modes = {\r\n  test: location.search.indexOf('test=1') > 0/*  || true */,\r\n  debug: location.search.indexOf('debug=1') > 0,\r\n  http: false, //location.search.indexOf('http=1') > 0,\r\n  ssl: true, // location.search.indexOf('ssl=1') > 0 || location.protocol === 'https:' && location.search.indexOf('ssl=0') === -1,\r\n  multipleConnections: true,\r\n  asServiceWorker: false\r\n};\r\n\r\n                  \r\n                             \r\n          \r\n\r\nexport default Modes;\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport Modes from \"./modes\";\r\n\r\nexport const DEBUG = process.env.NODE_ENV !== 'production' || Modes.debug;\r\nconst ctx: any = typeof(window) !== 'undefined' ? window : self;\r\nexport const MOUNT_CLASS_TO: any = DEBUG || true/*  && false */ ? ctx : {};\r\nexport default DEBUG;\r\n\r\n//let m = DEBUG;\r\n/* if(!DEBUG) {\r\n  ctx.sandpitTurtle = () => {\r\n    //if(!m) {\r\n      for(let i in MOUNT_CLASS_TO) {\r\n        ctx[i] = MOUNT_CLASS_TO[i];\r\n      }\r\n      //m = true;\r\n    //}\r\n  \r\n    //DEBUG = !DEBUG;\r\n  };\r\n} */\r\n\r\n/* export const superDebug = (object: any, key: string) => {\r\n  var d = object[key];\r\n  var beforeStr = '', afterStr = '';\r\n  for(var r of d) {\r\n    beforeStr += r.before.hex + '\\n';\r\n    afterStr += r.after.hex + '\\n';\r\n  }\r\n\r\n  beforeStr = beforeStr.trim();\r\n  afterStr = afterStr.trim();\r\n  //var beforeStr = d.map(r => r.before.hex).join('\\n');\r\n  //var afterStr = d.map(r => r.after.hex).join('\\n');\r\n\r\n  var dada = (name: string, str: string) => {\r\n    var a = document.createElement('a');\r\n    a.target = '_blank';\r\n    a.download = name + '.txt';\r\n    a.href = URL.createObjectURL(new Blob([str], {\r\n      type: 'text/plain'\r\n    }));\r\n    document.body.append(a);\r\n    a.click();\r\n  };\r\n\r\n  dada(key + '_' + 'before', beforeStr);\r\n  dada(key + '_' + 'after', afterStr);\r\n}\r\n\r\nMOUNT_CLASS_TO.superDebug = superDebug; */\r\n","/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\nimport type { Message, StickerSet, Update, NotifyPeer, PeerNotifySettings, ConstructorDeclMap } from \"../layer\";\r\nimport type { MyDocument } from \"./appManagers/appDocsManager\";\r\nimport type { AppMessagesManager, Dialog, MessagesStorage } from \"./appManagers/appMessagesManager\";\r\nimport type { Poll, PollResults } from \"./appManagers/appPollsManager\";\r\nimport type { MyDialogFilter } from \"./storages/filters\";\r\nimport type { ConnectionStatusChange } from \"../types\";\r\nimport type { UserTyping } from \"./appManagers/appChatsManager\";\r\nimport type Chat from \"../components/chat/chat\";\r\nimport type { UserAuth } from \"./mtproto/mtproto_config\";\r\nimport type { State, Theme } from \"./appManagers/appStateManager\";\r\nimport type { MyDraftMessage } from \"./appManagers/appDraftsManager\";\r\nimport EventListenerBase from \"../helpers/eventListenerBase\";\r\nimport { MOUNT_CLASS_TO } from \"../config/debug\";\r\n\r\nexport type BroadcastEvents = {\r\n  'user_update': number,\r\n  'user_auth': UserAuth,\r\n  'peer_changed': number,\r\n  'peer_changing': Chat,\r\n  'peer_pinned_messages': {peerId: number, mids?: number[], pinned?: boolean, unpinAll?: true},\r\n  'peer_pinned_hidden': {peerId: number, maxId: number},\r\n  'peer_typings': {peerId: number, typings: UserTyping[]},\r\n  'peer_block': {peerId: number, blocked: boolean},\r\n  'peer_title_edit': number,\r\n  'peer_bio_edit': number,\r\n\r\n  'filter_delete': MyDialogFilter,\r\n  'filter_update': MyDialogFilter,\r\n  'filter_order': number[],\r\n  \r\n  'dialog_draft': {peerId: number, draft: MyDraftMessage | undefined, index: number},\r\n  'dialog_unread': {peerId: number},\r\n  'dialog_flush': {peerId: number},\r\n  'dialog_drop': {peerId: number, dialog?: Dialog},\r\n  'dialog_migrate': {migrateFrom: number, migrateTo: number},\r\n  //'dialog_top': Dialog,\r\n  'dialog_notify_settings': Dialog,\r\n  'dialogs_multiupdate': {[peerId: string]: Dialog},\r\n  'dialogs_archived_unread': {count: number},\r\n  \r\n  'history_append': {storage: MessagesStorage, peerId: number, mid: number},\r\n  'history_update': {storage: MessagesStorage, peerId: number, mid: number},\r\n  'history_reply_markup': {peerId: number},\r\n  'history_multiappend': AppMessagesManager['newMessagesToHandle'],\r\n  'history_delete': {peerId: number, msgs: {[mid: number]: true}},\r\n  'history_forbidden': number,\r\n  'history_reload': number,\r\n  'history_focus': {peerId: number, mid?: number},\r\n  //'history_request': void,\r\n  \r\n  'message_edit': {storage: MessagesStorage, peerId: number, mid: number},\r\n  'message_views': {mid: number, views: number},\r\n  'message_sent': {storage: MessagesStorage, tempId: number, tempMessage: any, mid: number},\r\n  'messages_pending': void,\r\n  'messages_read': void,\r\n  'messages_downloaded': {peerId: number, mids: number[]},\r\n  'messages_media_read': {peerId: number, mids: number[]},\r\n\r\n  'replies_updated': Message.message,\r\n\r\n  'scheduled_new': {peerId: number, mid: number},\r\n  'scheduled_delete': {peerId: number, mids: number[]},\r\n\r\n  'album_edit': {peerId: number, groupId: string, deletedMids: number[]},\r\n\r\n  'stickers_installed': StickerSet.stickerSet,\r\n  'stickers_deleted': StickerSet.stickerSet,\r\n\r\n  'audio_play': {doc: MyDocument, mid: number, peerId: number},\r\n  'audio_pause': void,\r\n  \r\n  'state_synchronized': number,\r\n  'state_synchronizing': number,\r\n  \r\n  'contacts_update': number,\r\n  'avatar_update': number,\r\n  'chat_full_update': number,\r\n  'poll_update': {poll: Poll, results: PollResults},\r\n  'chat_update': number,\r\n  //'channel_settings': {channelId: number},\r\n  'webpage_updated': {id: string, msgs: number[]},\r\n\r\n  'download_progress': any,\r\n  'connection_status_change': ConnectionStatusChange,\r\n  'settings_updated': {key: string, value: any},\r\n  'draft_updated': {peerId: number, threadId: number, draft: MyDraftMessage | undefined},\r\n\r\n  'event-heavy-animation-start': void,\r\n  'event-heavy-animation-end': void,\r\n\r\n  'im_mount': void,\r\n  'im_tab_change': number,\r\n\r\n  'idle': boolean,\r\n\r\n  'overlay_toggle': boolean,\r\n\r\n  'background_change': void,\r\n\r\n  'privacy_update': Update.updatePrivacy,\r\n\r\n  'notify_settings': Update.updateNotifySettings,\r\n  'notify_peer_type_settings': {key: Exclude<NotifyPeer['_'], 'notifyPeer'>, settings: PeerNotifySettings},\r\n\r\n  'language_change': void,\r\n  \r\n  'theme_change': void,\r\n\r\n  'instance_deactivated': void\r\n};\r\n\r\nexport class RootScope extends EventListenerBase<{\r\n  [name in Update['_']]: (update: ConstructorDeclMap[name]) => void\r\n} & {\r\n  [name in keyof BroadcastEvents]: (e: BroadcastEvents[name]) => void\r\n}> {\r\n  private _overlayIsActive: boolean = false;\r\n  public myId = 0;\r\n  public idle = {\r\n    isIDLE: true,\r\n    deactivated: false,\r\n    focusPromise: Promise.resolve(),\r\n    focusResolve: () => {}\r\n  };\r\n  public connectionStatus: {[name: string]: ConnectionStatusChange} = {};\r\n  public settings: State['settings'];\r\n  public peerId = 0;\r\n  public systemTheme: Theme['name'];\r\n\r\n  constructor() {\r\n    super();\r\n\r\n    this.on('peer_changed', (peerId) => {\r\n      this.peerId = peerId;\r\n    });\r\n\r\n    this.on('user_auth', (e) => {\r\n      this.myId = e.id;\r\n    });\r\n\r\n    this.on('connection_status_change', (e) => {\r\n      const status = e;\r\n      this.connectionStatus[e.name] = status;\r\n    });\r\n\r\n    this.on('idle', (isIDLE) => {\r\n      if(isIDLE) {\r\n        this.idle.focusPromise = new Promise((resolve) => {\r\n          this.idle.focusResolve = resolve;\r\n        });\r\n      } else {\r\n        this.idle.focusResolve();\r\n      }\r\n    });\r\n  }\r\n\r\n  public setThemeListener() {\r\n    try {\r\n      const darkModeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');\r\n      const checkDarkMode = () => {\r\n        //const theme = this.getTheme();\r\n        this.systemTheme = darkModeMediaQuery.matches ? 'night' : 'day';\r\n        //const newTheme = this.getTheme();\r\n\r\n        if(this.myId) {\r\n          this.broadcast('theme_change');\r\n        } else {\r\n          this.setTheme();\r\n        }\r\n      };\r\n\r\n      if('addEventListener' in darkModeMediaQuery) {\r\n        darkModeMediaQuery.addEventListener('change', checkDarkMode);\r\n      } else if('addListener' in darkModeMediaQuery) {\r\n        (darkModeMediaQuery as any).addListener(checkDarkMode);\r\n      }\r\n\r\n      checkDarkMode();\r\n    } catch(err) {\r\n\r\n    }\r\n  }\r\n\r\n  public setTheme() {\r\n    const isNight = this.getTheme().name === 'night';\r\n    const colorScheme = document.head.querySelector('[name=\"color-scheme\"]');\r\n    if(colorScheme) {\r\n      colorScheme.setAttribute('content', isNight ? 'dark' : 'light');\r\n    }\r\n\r\n    document.documentElement.classList.toggle('night', isNight);\r\n  }\r\n\r\n  get overlayIsActive() {\r\n    return this._overlayIsActive;\r\n  }\r\n\r\n  set overlayIsActive(value: boolean) {\r\n    this._overlayIsActive = value;\r\n    this.broadcast('overlay_toggle', value);\r\n  }\r\n\r\n  public getTheme(name: Theme['name'] = this.settings.theme === 'system' ? this.systemTheme : this.settings.theme) {\r\n    return this.settings.themes.find(t => t.name === name);\r\n  }\r\n\r\n  public broadcast = <T extends keyof BroadcastEvents>(name: T, detail?: BroadcastEvents[T]) => {\r\n    /* //if(DEBUG) {\r\n      if(name !== 'user_update') {\r\n        console.debug('Broadcasting ' + name + ' event, with args:', detail);\r\n      }\r\n    //} */\r\n\r\n    this.dispatchEvent(name, detail);\r\n  };\r\n\r\n  public on = <T extends keyof BroadcastEvents>(name: T, callback: (e: BroadcastEvents[T]) => any, once?: true) => {\r\n    super.addEventListener(name, callback, once);\r\n  };\r\n\r\n  public addEventListener = this.on;\r\n\r\n  public off = <T extends keyof BroadcastEvents>(name: T, callback: (e: BroadcastEvents[T]) => any) => {\r\n    super.removeEventListener(name, callback);\r\n  };\r\n\r\n  public removeEventListener = this.off;\r\n}\r\n\r\nconst rootScope = new RootScope();\r\nMOUNT_CLASS_TO.rootScope = rootScope;\r\nexport default rootScope;\r\n\r\n/* rootScope.addEventListener('album_edit', (e) => {\r\n  \r\n});\r\n\r\nrootScope.addEventListener<'album_edit'>('album_edit', (e) => {\r\n  \r\n}); */\r\n"],"sourceRoot":""}