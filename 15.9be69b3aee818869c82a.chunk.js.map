{"version":3,"sources":["webpack:///./src/config/debug.ts","webpack:///./src/helpers/schedulers.ts","webpack:///./src/helpers/cancellablePromise.ts","webpack:///./src/helpers/eventListenerBase.ts","webpack:///./src/config/modes.ts","webpack:///./src/lib/rootScope.ts"],"names":["DEBUG","debug","ctx","window","self","MOUNT_CLASS_TO","sandpitTurtle","i","debounce","fn","ms","shouldRunFirst","shouldRunLast","waitingTimeout","args","clearTimeout","setTimeout","throttle","isPending","interval","_args","setInterval","clearInterval","pause","Promise","resolve","fastRafCallbacks","fastRaf","callback","push","requestAnimationFrame","currentCallbacks","undefined","forEach","cb","doubleRaf","deferredPromise","deferredHelper","isFulfilled","isRejected","notify","notifyAll","lastNotify","listeners","addNotifyListener","deferred","reject","value","finally","length","cancel","Object","assign","EventListenerBase","reuseResults","this","_constructor","listenerResults","name","once","hasOwnProperty","findAndSplice","l","arr","slice","listener","findIndex","removeEventListener","Modes","test","location","search","indexOf","http","ssl","multipleConnections","asServiceWorker","RootScope","super","_overlayIsActive","myId","idle","isIDLE","connectionStatus","broadcast","detail","dispatchEvent","on","addEventListener","off","e","status","rootScope"],"mappings":"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","file":"15.9be69b3aee818869c82a.chunk.js","sourcesContent":["/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport Modes from \"./modes\";\n\nexport const DEBUG = process.env.NODE_ENV !== 'production' || Modes.debug;\nconst ctx: any = typeof(window) !== 'undefined' ? window : self;\nexport const MOUNT_CLASS_TO: any = DEBUG/*  && false */ ? ctx : {};\nexport default DEBUG;\n\n//let m = DEBUG;\nif(!DEBUG/*  || true */) {\n  ctx.sandpitTurtle = () => {\n    //if(!m) {\n      for(let i in MOUNT_CLASS_TO) {\n        ctx[i] = MOUNT_CLASS_TO[i];\n      }\n      //m = true;\n    //}\n  \n    //DEBUG = !DEBUG;\n  };\n}\n\n/* export const superDebug = (object: any, key: string) => {\n  var d = object[key];\n  var beforeStr = '', afterStr = '';\n  for(var r of d) {\n    beforeStr += r.before.hex + '\\n';\n    afterStr += r.after.hex + '\\n';\n  }\n\n  beforeStr = beforeStr.trim();\n  afterStr = afterStr.trim();\n  //var beforeStr = d.map(r => r.before.hex).join('\\n');\n  //var afterStr = d.map(r => r.after.hex).join('\\n');\n\n  var dada = (name: string, str: string) => {\n    var a = document.createElement('a');\n    a.target = '_blank';\n    a.download = name + '.txt';\n    a.href = URL.createObjectURL(new Blob([str], {\n      type: 'text/plain'\n    }));\n    document.body.append(a);\n    a.click();\n  };\n\n  dada(key + '_' + 'before', beforeStr);\n  dada(key + '_' + 'after', afterStr);\n}\n\nMOUNT_CLASS_TO.superDebug = superDebug; */\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\n// * Jolly Cobra's schedulers\nimport { AnyToVoidFunction, NoneToVoidFunction } from \"../types\";\n\n//type Scheduler = typeof requestAnimationFrame | typeof onTickEnd | typeof runNow;\n\nexport function debounce<F extends AnyToVoidFunction>(\n  fn: F,\n  ms: number,\n  shouldRunFirst = true,\n  shouldRunLast = true,\n) {\n  let waitingTimeout: number | null = null;\n\n  return (...args: Parameters<F>) => {\n    if(waitingTimeout) {\n      clearTimeout(waitingTimeout);\n      waitingTimeout = null;\n    } else if(shouldRunFirst) {\n      // @ts-ignore\n      fn(...args);\n    }\n\n    waitingTimeout = setTimeout(() => {\n      if(shouldRunLast) {\n        // @ts-ignore\n        fn(...args);\n      }\n\n      waitingTimeout = null;\n    }, ms) as any;\n  };\n}\n\nexport function throttle<F extends AnyToVoidFunction>(\n  fn: F,\n  ms: number,\n  shouldRunFirst = true,\n) {\n  let interval: number | null = null;\n  let isPending: boolean;\n  let args: Parameters<F>;\n\n  return (..._args: Parameters<F>) => {\n    isPending = true;\n    args = _args;\n\n    if (!interval) {\n      if (shouldRunFirst) {\n        isPending = false;\n        // @ts-ignore\n        fn(...args);\n      }\n\n      interval = window.setInterval(() => {\n        if (!isPending) {\n          window.clearInterval(interval!);\n          interval = null;\n          return;\n        }\n\n        isPending = false;\n        // @ts-ignore\n        fn(...args);\n      }, ms);\n    }\n  };\n}\n\n/* export function throttleWithRaf<F extends AnyToVoidFunction>(fn: F) {\n  return throttleWith(fastRaf, fn);\n}\n\nexport function throttleWithTickEnd<F extends AnyToVoidFunction>(fn: F) {\n  return throttleWith(onTickEnd, fn);\n}\n\nexport function throttleWithNow<F extends AnyToVoidFunction>(fn: F) {\n  return throttleWith(runNow, fn);\n}\n\nexport function throttleWith<F extends AnyToVoidFunction>(schedulerFn: Scheduler, fn: F) {\n  let waiting = false;\n  let args: Parameters<F>;\n\n  return (..._args: Parameters<F>) => {\n    args = _args;\n\n    if (!waiting) {\n      waiting = true;\n\n      schedulerFn(() => {\n        waiting = false;\n        // @ts-ignore\n        fn(...args);\n      });\n    }\n  };\n}\n\nexport function onTickEnd(cb: NoneToVoidFunction) {\n  Promise.resolve().then(cb);\n}\n\nfunction runNow(fn: NoneToVoidFunction) {\n  fn();\n} */\n\nexport const pause = (ms: number) => new Promise<void>((resolve) => {\n  setTimeout(resolve, ms);\n});\n\nlet fastRafCallbacks: NoneToVoidFunction[] | undefined;\nexport function fastRaf(callback: NoneToVoidFunction) {\n  if(!fastRafCallbacks) {\n    fastRafCallbacks = [callback];\n\n    requestAnimationFrame(() => {\n      const currentCallbacks = fastRafCallbacks!;\n      fastRafCallbacks = undefined;\n      currentCallbacks.forEach((cb) => cb());\n    });\n  } else {\n    fastRafCallbacks.push(callback);\n  }\n}\n\nexport function doubleRaf() {\n  return new Promise<void>((resolve) => {\n    fastRaf(() => {\n      fastRaf(resolve);\n    });\n  });\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nexport interface CancellablePromise<T> extends Promise<T> {\n  resolve?: (...args: any[]) => void,\n  reject?: (...args: any[]) => void,\n  cancel?: () => void,\n\n  notify?: (...args: any[]) => void,\n  notifyAll?: (...args: any[]) => void,\n  lastNotify?: any,\n  listeners?: Array<(...args: any[]) => void>,\n  addNotifyListener?: (callback: (...args: any[]) => void) => void,\n\n  isFulfilled?: boolean,\n  isRejected?: boolean\n}\n\nexport function deferredPromise<T>() {\n  let deferredHelper: any = {\n    isFulfilled: false, \n    isRejected: false,\n\n    notify: () => {}, \n    notifyAll: (...args: any[]) => {\n      deferredHelper.lastNotify = args;\n      deferredHelper.listeners.forEach((callback: any) => callback(...args));\n    }, \n\n    lastNotify: undefined,\n    listeners: [],\n    addNotifyListener: (callback: (...args: any[]) => void) => {\n      if(deferredHelper.lastNotify) {\n        callback(...deferredHelper.lastNotify);\n      }\n\n      deferredHelper.listeners.push(callback);\n    }\n  };\n\n  let deferred: CancellablePromise<T> = new Promise<T>((resolve, reject) => {\n    deferredHelper.resolve = (value: T) => {\n      if(deferred.isFulfilled) return;\n\n      deferred.isFulfilled = true;\n      resolve(value);\n    };\n    \n    deferredHelper.reject = (...args: any[]) => {\n      if(deferred.isRejected) return;\n      \n      deferred.isRejected = true;\n      reject(...args);\n    };\n  });\n\n  // @ts-ignore\n  /* deferred.then = (resolve: (value: T) => any, reject: (...args: any[]) => any) => {\n    const n = deferredPromise<ReturnType<typeof resolve>>();\n    \n  }; */\n\n  deferred.finally(() => {\n    deferred.notify = null;\n    deferred.listeners.length = 0;\n    deferred.lastNotify = null;\n\n    if(deferred.cancel) {\n      deferred.cancel = () => {};\n    }\n  });\n\n  Object.assign(deferred, deferredHelper);\n\n  return deferred;\n}","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\n//import { MOUNT_CLASS_TO } from \"../config/debug\";\nimport type { ArgumentTypes, SuperReturnType } from \"../types\";\n\n// class EventSystem {\n//   wm: WeakMap<any, Record<any, Set<any>>> = new WeakMap();\n\n//   add(target: any, event: any, listener: any) {\n//     let listeners = this.wm.get(target);\n//     if (listeners === undefined) {\n//         listeners = {};\n//     }\n//     let listenersForEvent = listeners[event];\n//     if (listenersForEvent === undefined) {\n//         listenersForEvent = new Set();\n//     }\n//     listenersForEvent.add(listener);\n//     listeners[event] = listenersForEvent;\n//     //target.addEventListener(event, listener);\n//     this.wm.set(target, listeners);\n//   };\n\n//   remove(target: any, event: any, listener: any) {\n//     let listeners = this.wm.get(target);\n//     if (!listeners) return;\n//     let listenersForEvent = listeners[event];\n//     if (!listenersForEvent) return;\n//     listenersForEvent.delete(listener);\n//   };\n  \n//   /* fire(target, event) {\n//      let listeners = this.wm.get(target);\n//      if (!listeners) return;\n//      let listenersForEvent = listeners[event];\n//      if (!listenersForEvent) return;\n//      for (let handler of handlers) {\n//          setTimeout(handler, 0, event, target); // we use a setTimeout here because we want event triggering to be asynchronous. \n//      }\n//   }; */\n// }\n\n// console.log = () => {};\n\n// const e = new EventSystem();\n// MOUNT_CLASS_TO.e = e;\n\n/**\n * Better not to remove listeners during setting\n * Should add listener callback only once\n */\nexport default class EventListenerBase<Listeners extends {[name: string]: Function}> {\n  protected listeners: Partial<{\n    [k in keyof Listeners]: Array<{callback: Listeners[k], once?: boolean}>\n  }>;\n  protected listenerResults: Partial<{\n    [k in keyof Listeners]: ArgumentTypes<Listeners[k]>\n  }>;\n\n  private reuseResults: boolean;\n\n  constructor(reuseResults?: boolean) {\n    this._constructor(reuseResults);\n  }\n\n  public _constructor(reuseResults = false): any {\n    this.reuseResults = reuseResults;\n    this.listeners = {};\n    this.listenerResults = {};\n  }\n\n  public addEventListener(name: keyof Listeners, callback: Listeners[typeof name], once?: boolean) {\n    if(this.listenerResults.hasOwnProperty(name)) {\n      callback(...this.listenerResults[name]);\n      \n      if(once) {\n        return;\n      }\n    }\n    \n    (this.listeners[name] ?? (this.listeners[name] = [])).push({callback, once});\n    //e.add(this, name, {callback, once});\n  }\n\n  public removeEventListener(name: keyof Listeners, callback: Listeners[typeof name]) {\n    if(this.listeners[name]) {\n      this.listeners[name].findAndSplice(l => l.callback === callback);\n    }\n    //e.remove(this, name, callback);\n  }\n\n  // * must be protected, but who cares\n  public dispatchEvent(name: keyof Listeners, ...args: ArgumentTypes<Listeners[typeof name]>) {\n    if(this.reuseResults) {\n      this.listenerResults[name] = args;\n    }\n\n    const arr: Array<SuperReturnType<Listeners[typeof name]>> = [];\n\n    /* let a = e.wm.get(this)[name];\n    if(!a) return arr;\n    const listeners = [...a]; */\n    const listeners = this.listeners[name];\n    if(listeners) {\n      // ! this one will guarantee execution even if delete another listener during setting\n      const left = listeners.slice();\n      left.forEach((listener: any) => {\n        const index = listeners.findIndex((l: any) => l.callback === listener.callback);\n        if(index === -1) {\n          return;\n        }\n\n        arr.push(listener.callback(...args));\n\n        if(listener.once) {\n          this.removeEventListener(name, listener.callback);\n        }\n      });\n\n      /* for(let i = 0, length = listeners.length; i < length; ++i) {\n        const listener = listeners[i];\n        arr.push(listener.callback(...args));\n\n        if(listener.once) {\n          listeners.splice(i, 1);\n          --i;\n          --length;\n        }\n      } */\n    }\n\n    return arr;\n  }\n\n  public cleanup() {\n    this.listeners = {}; \n    this.listenerResults = {};\n  }\n}\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n * \n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nconst Modes = {\n  test: location.search.indexOf('test=1') > 0/*  || true */,\n  debug: location.search.indexOf('debug=1') > 0,\n  http: false, //location.search.indexOf('http=1') > 0,\n  ssl: true, // location.search.indexOf('ssl=1') > 0 || location.protocol === 'https:' && location.search.indexOf('ssl=0') === -1,\n  multipleConnections: true,\n  asServiceWorker: false\n};\n\n//////////////////\n/////////////////////////////\n//////////\n\nexport default Modes;\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport type { Message, StickerSet, Update, NotifyPeer, PeerNotifySettings } from \"../layer\";\nimport type { MyDocument } from \"./appManagers/appDocsManager\";\nimport type { AppMessagesManager, Dialog, MessagesStorage } from \"./appManagers/appMessagesManager\";\nimport type { Poll, PollResults } from \"./appManagers/appPollsManager\";\nimport type { MyDialogFilter } from \"./storages/filters\";\nimport type { ConnectionStatusChange } from \"../types\";\nimport type { UserTyping } from \"./appManagers/appChatsManager\";\nimport type Chat from \"../components/chat/chat\";\nimport type { UserAuth } from \"./mtproto/mtproto_config\";\nimport type { State } from \"./appManagers/appStateManager\";\nimport type { MyDraftMessage } from \"./appManagers/appDraftsManager\";\nimport EventListenerBase from \"../helpers/eventListenerBase\";\nimport { MOUNT_CLASS_TO } from \"../config/debug\";\n\nexport type BroadcastEvents = {\n  'user_update': number,\n  'user_auth': UserAuth,\n  'peer_changed': number,\n  'peer_changing': Chat,\n  'peer_pinned_messages': {peerId: number, mids?: number[], pinned?: boolean, unpinAll?: true},\n  'peer_pinned_hidden': {peerId: number, maxId: number},\n  'peer_typings': {peerId: number, typings: UserTyping[]},\n  'peer_block': {peerId: number, blocked: boolean},\n  'peer_title_edit': number,\n  'peer_bio_edit': number,\n\n  'filter_delete': MyDialogFilter,\n  'filter_update': MyDialogFilter,\n  'filter_order': number[],\n  \n  'dialog_draft': {peerId: number, draft: MyDraftMessage | undefined, index: number},\n  'dialog_unread': {peerId: number},\n  'dialog_flush': {peerId: number},\n  'dialog_drop': {peerId: number, dialog?: Dialog},\n  'dialog_migrate': {migrateFrom: number, migrateTo: number},\n  //'dialog_top': Dialog,\n  'dialog_notify_settings': Dialog,\n  'dialogs_multiupdate': {[peerId: string]: Dialog},\n  'dialogs_archived_unread': {count: number},\n  \n  'history_append': {storage: MessagesStorage, peerId: number, mid: number},\n  'history_update': {storage: MessagesStorage, peerId: number, mid: number},\n  'history_reply_markup': {peerId: number},\n  'history_multiappend': AppMessagesManager['newMessagesToHandle'],\n  'history_delete': {peerId: number, msgs: {[mid: number]: true}},\n  'history_forbidden': number,\n  'history_reload': number,\n  'history_focus': number,\n  //'history_request': void,\n  \n  'message_edit': {storage: MessagesStorage, peerId: number, mid: number},\n  'message_views': {mid: number, views: number},\n  'message_sent': {storage: MessagesStorage, tempId: number, tempMessage: any, mid: number},\n  'messages_pending': void,\n  'messages_read': void,\n  'messages_downloaded': {peerId: number, mids: number[]},\n  'messages_media_read': {peerId: number, mids: number[]},\n\n  'replies_updated': Message.message,\n\n  'scheduled_new': {peerId: number, mid: number},\n  'scheduled_delete': {peerId: number, mids: number[]},\n\n  'album_edit': {peerId: number, groupId: string, deletedMids: number[]},\n\n  'stickers_installed': StickerSet.stickerSet,\n  'stickers_deleted': StickerSet.stickerSet,\n\n  'audio_play': {doc: MyDocument, mid: number, peerId: number},\n  'audio_pause': void,\n  \n  'state_synchronized': number,\n  'state_synchronizing': number,\n  \n  'contacts_update': number,\n  'avatar_update': number,\n  'chat_full_update': number,\n  'poll_update': {poll: Poll, results: PollResults},\n  'chat_update': number,\n  'channel_settings': {channelId: number},\n  'webpage_updated': {id: string, msgs: number[]},\n\n  'apiUpdate': Update,\n  'download_progress': any,\n  'connection_status_change': ConnectionStatusChange,\n  'settings_updated': {key: string, value: any},\n  'draft_updated': {peerId: number, threadId: number, draft: MyDraftMessage | undefined},\n\n  'event-heavy-animation-start': void,\n  'event-heavy-animation-end': void,\n\n  'im_mount': void,\n  'im_tab_change': number,\n\n  'idle': boolean,\n\n  'overlay_toggle': boolean,\n\n  'background_change': void,\n\n  'privacy_update': Update.updatePrivacy,\n\n  'notify_settings': Update.updateNotifySettings,\n  'notify_peer_type_settings': {key: Exclude<NotifyPeer['_'], 'notifyPeer'>, settings: PeerNotifySettings},\n\n  'language_change': void,\n};\n\nexport class RootScope extends EventListenerBase<any> {\n  private _overlayIsActive: boolean = false;\n  public myId = 0;\n  public idle = {\n    isIDLE: true\n  };\n  public connectionStatus: {[name: string]: ConnectionStatusChange} = {};\n  public settings: State['settings'];\n\n  constructor() {\n    super();\n\n    this.on('user_auth', (e) => {\n      this.myId = e;\n    });\n\n    this.on('connection_status_change', (e) => {\n      const status = e;\n      this.connectionStatus[e.name] = status;\n    });\n  }\n\n  get overlayIsActive() {\n    return this._overlayIsActive;\n  }\n\n  set overlayIsActive(value: boolean) {\n    this._overlayIsActive = value;\n    this.broadcast('overlay_toggle', value);\n  }\n\n  public broadcast = <T extends keyof BroadcastEvents>(name: T, detail?: BroadcastEvents[T]) => {\n    /* //if(DEBUG) {\n      if(name !== 'user_update') {\n        console.debug('Broadcasting ' + name + ' event, with args:', detail);\n      }\n    //} */\n\n    this.dispatchEvent(name, detail);\n  };\n\n  public on = <T extends keyof BroadcastEvents>(name: T, callback: (e: BroadcastEvents[T]) => any, once?: true) => {\n    super.addEventListener(name, callback, once);\n  };\n\n  public addEventListener = this.on;\n\n  public off = <T extends keyof BroadcastEvents>(name: T, callback: (e: BroadcastEvents[T]) => any) => {\n    super.removeEventListener(name, callback);\n  };\n\n  public removeEventListener = this.off;\n}\n\nconst rootScope = new RootScope();\nMOUNT_CLASS_TO.rootScope = rootScope;\nexport default rootScope;\n\nrootScope.addEventListener('album_edit', (e) => {\n  \n});\n\nrootScope.addEventListener<'album_edit'>('album_edit', (e) => {\n  \n});\n"],"sourceRoot":""}