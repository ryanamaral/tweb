{"version":3,"sources":["webpack:///./src/helpers/string.ts"],"names":["limitSymbols","str","length","limitFrom","trim","slice","escapeRegExp","replace","encodeEntities","value","charCodeAt","splitStringByLength","maxLength","lastSliceStartIndex","arrayIndex","out","cut","end","part","_arrayIndex","forEach","lastIndex","index","indexOf","partLength","convertInputKeyToKey","inputKey","toLowerCase","convertKeyToInputKey","key","toUpperCase","capitalizeFirstLetter","string","charAt"],"mappings":"sFAUO,SAASA,EAAaC,EAAaC,EAAgBC,EAAYD,EAAS,IAM7E,OALAD,EAAMA,EAAIG,QACHF,OAASC,IACdF,EAAMA,EAAII,MAAM,EAAGH,GAAoC,OAGlDD,EAIF,SAASK,EAAaL,GAC3B,OAAOA,EACJM,QAAQ,sBAAuB,QAC/BA,QAAQ,KAAM,SAGZ,SAASC,EAAeC,GAC7B,OAAOA,EAAMF,QAAQ,KAAM,SAASA,QAAQ,kCAAoCE,GAGvE,MAAyB,MAFvBA,EAAMC,WAAW,GAEJ,QADZD,EAAMC,WAAW,GACqB,OAAU,OAAW,KACpEH,QAAQ,iBAAmBE,GACrB,KAAOA,EAAMC,WAAW,GAAK,KACnCH,QAAQ,KAAM,QAAQA,QAAQ,KAAM,QAGlC,SAASI,EAAoBV,EAAaW,GAC/C,GAAGX,EAAIC,OAASU,EAAW,MAAO,CAACX,GACnC,IAAIC,EAAS,EAAGW,EAAsB,EAAGC,EAAa,EACtD,MACMC,EAAgB,GAEhBC,EAAOC,IACX,IAAIC,EAAOjB,EAAII,MAAMQ,EAAqBI,GAC1C,MAAME,EAAcL,IACpB,GAAGI,EAAKhB,OAASU,EAAW,CAETD,EADEO,EAAKb,MAAMO,GACqBA,GAC1CQ,QAAQF,IACfH,EAAID,KAAgBI,IAGtBA,EAAOA,EAAKb,MAAM,EAAGO,GAGvBC,EAAsBI,EACtBf,EAAS,EACTa,EAAII,IAAgBJ,EAAII,IAAgB,IAAMD,GAGhD,IAAIG,EAAY,EAChB,OAAG,CACD,IAAIC,EAAQrB,EAAIsB,QAvBA,IAuBmBF,GACnC,IAAc,IAAXC,EAAc,CACZD,IAAepB,EAAIC,OAAS,GAC7Bc,IAGF,MAGFM,GAhCgB,IAgCGpB,OAEnB,MAAMsB,EAAaF,EAAQD,EACvBnB,EAASsB,EAAcZ,GACzBI,EAAId,GAGNmB,EAAYC,EACZpB,GAAUsB,EAGZ,OAAOT,EAlFT,8OAgGO,SAASU,EAAqBC,GACnC,MAAMzB,EAAMyB,EAASnB,QAAQ,QAAS,IACtC,OAAQN,EAAI,GAAG0B,cAAgB1B,EAAII,MAAM,GAGpC,SAASuB,EAAqBC,GAGnC,OADAA,EAAM,SADNA,EAAMA,EAAI,GAAGC,cAAgBD,EAAIxB,MAAM,IAKlC,SAAS0B,EAAsBC,GACpC,OAAOA,EAAOC,OAAO,GAAGH,cAAgBE,EAAO3B,MAAM","file":"22.3953b7734f759c67a22f.chunk.js","sourcesContent":["/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n */\r\n\r\n/* export function stringMiddleOverflow(str: string, maxLength: number) {\r\n  return str.length > maxLength ? str.slice(0, maxLength / 2 | 0) + '...' + str.slice(-Math.round(maxLength / 2)) : str; \r\n} */\r\n\r\nexport function limitSymbols(str: string, length: number, limitFrom = length + 10) {\r\n  str = str.trim();\r\n  if(str.length > limitFrom) {\r\n    str = str.slice(0, length)/* .replace(/\\s*$/, '') */ + '...';\r\n  }\r\n\r\n  return str;\r\n}\r\n\r\n// credits to https://github.com/sindresorhus/escape-string-regexp/blob/master/index.js\r\nexport function escapeRegExp(str: string) {\r\n  return str\r\n    .replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\r\n    .replace(/-/g, '\\\\x2d');\r\n}\r\n\r\nexport function encodeEntities(value: string) {\r\n  return value.replace(/&/g, '&amp;').replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, (value) => {\r\n    var hi = value.charCodeAt(0);\r\n    var low = value.charCodeAt(1);\r\n    return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';\r\n  }).replace(/([^\\#-~| |!])/g, (value) => { // non-alphanumeric\r\n    return '&#' + value.charCodeAt(0) + ';';\r\n  }).replace(/</g, '&lt;').replace(/>/g, '&gt;');\r\n}\r\n\r\nexport function splitStringByLength(str: string, maxLength: number) {\r\n  if(str.length < maxLength) return [str];\r\n  let length = 0, lastSliceStartIndex = 0, arrayIndex = 0;\r\n  const delimiter = ' ';//'\\n';\r\n  const out: string[] = [];\r\n\r\n  const cut = (end?: number) => {\r\n    let part = str.slice(lastSliceStartIndex, end);\r\n    const _arrayIndex = arrayIndex++;\r\n    if(part.length > maxLength) {\r\n      let overflowPart = part.slice(maxLength);\r\n      const splitted = splitStringByLength(overflowPart, maxLength);\r\n      splitted.forEach(part => {\r\n        out[arrayIndex++] = part;\r\n      });\r\n\r\n      part = part.slice(0, maxLength);\r\n    }\r\n\r\n    lastSliceStartIndex = end;\r\n    length = 0;\r\n    out[_arrayIndex] = (out[_arrayIndex] || '') + part;\r\n  };\r\n\r\n  let lastIndex = 0;\r\n  do {\r\n    let index = str.indexOf(delimiter, lastIndex);\r\n    if(index === -1) {\r\n      if(lastIndex !== (str.length - 1)) {\r\n        cut();\r\n      }\r\n\r\n      break;\r\n    }\r\n\r\n    index += delimiter.length;\r\n\r\n    const partLength = index - lastIndex;\r\n    if((length + partLength) > maxLength) {\r\n      cut(length);\r\n    }\r\n    \r\n    lastIndex = index;\r\n    length += partLength;\r\n  } while(true);\r\n\r\n  return out;\r\n}\r\n\r\n// https://stackoverflow.com/a/14824756\r\nexport const checkRTL = (s: string) => {           \r\n  const ltrChars  = 'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF'+'\\u2C00-\\uFB1C\\uFDFE-\\uFE6F\\uFEFD-\\uFFFF',\r\n    rtlChars      = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC',\r\n    rtlDirCheck   = new RegExp('^[^'+ltrChars+']*['+rtlChars+']');\r\n\r\n  return rtlDirCheck.test(s);\r\n};\r\n\r\n//(window as any).checkRTL = checkRTL;\r\n\r\nexport function convertInputKeyToKey(inputKey: string) {\r\n  const str = inputKey.replace('input', '');\r\n  return (str[0].toLowerCase() + str.slice(1)) as string;\r\n}\r\n\r\nexport function convertKeyToInputKey(key: string) {\r\n  key = key[0].toUpperCase() + key.slice(1);\r\n  key = 'input' + key;\r\n  return key;\r\n}\r\n\r\nexport function capitalizeFirstLetter(string: string) {\r\n  return string.charAt(0).toUpperCase() + string.slice(1);\r\n}\r\n"],"sourceRoot":""}