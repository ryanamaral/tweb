{"version":3,"sources":["webpack:///./src/lib/crypto/srp.ts"],"names":["Error","makePasswordHash","password","client_salt","server_salt","buffer","sha256Hash","TextEncoder","encode","hash","pbkdf2","Uint8Array","computeSRP","state","isNew","algo","new_algo","current_algo","p","B","srp_B","g","pw_hash","salt1","salt2","x","padArray","arr","len","fill","Array","concat","slice","pForHash","gForHash","b_for_hash","v","flipper","out","length","i","k","k_v","is_good_mod_exp_first","modexp","prime","diff","Math","floor","g_b","a","a_for_hash","u","secure_random","A","s","generate_and_check_random","ux","a_ux","S","K","h1","h2","buff","M1","_","srp_id"],"mappings":"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","file":"1.b1c2b735403e4b51b88d.worker.js","sourcesContent":["import CryptoWorker from \"../crypto/cryptoworker\";\nimport {str2bigInt, isZero,\n  bigInt2str, powMod, int2bigInt, mult, mod, sub, bitSize, negative, add, greater} from '../../vendor/leemon';\n\nimport {logger, LogTypes} from '../logger';\nimport { AccountPassword, PasswordKdfAlgo } from \"../../layer\";\nimport { bufferConcats, bytesToHex, bytesFromHex, bufferConcat, bytesXor } from \"../../helpers/bytes\";\n//import { MOUNT_CLASS_TO } from \"../../config/debug\";\n\nconst log = logger('SRP', LogTypes.Error);\n\n//MOUNT_CLASS_TO && Object.assign(MOUNT_CLASS_TO, {str2bigInt, bigInt2str, int2bigInt});\n\nexport async function makePasswordHash(password: string, client_salt: Uint8Array, server_salt: Uint8Array): Promise<number[]> {\n  // ! look into crypto_methods.test.ts\n  let buffer: any = await CryptoWorker.sha256Hash(bufferConcats(client_salt, new TextEncoder().encode(password), client_salt));\n  //log('encoded 1', bytesToHex(new Uint8Array(buffer)));\n\n  buffer = bufferConcats(server_salt, buffer, server_salt);\n\n  buffer = await CryptoWorker.sha256Hash(buffer);\n  //log('encoded 2', buffer, bytesToHex(new Uint8Array(buffer)));\n\n  let hash = await CryptoWorker.pbkdf2(new Uint8Array(buffer), client_salt, 100000);\n  //log('encoded 3', hash, bytesToHex(new Uint8Array(hash)));\n\n  hash = bufferConcats(server_salt, hash, server_salt);\n\n  buffer = await CryptoWorker.sha256Hash(hash);\n  //log('got password hash:', buffer, bytesToHex(new Uint8Array(buffer)));\n\n  return buffer;\n}\n\nexport async function computeSRP(password: string, state: AccountPassword, isNew: boolean) {\n  const algo = (isNew ? state.new_algo : state.current_algo) as PasswordKdfAlgo.passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow;\n  //console.log('computeSRP:', password, state, isNew, algo);\n\n  const p = str2bigInt(bytesToHex(algo.p), 16);\n  const B = str2bigInt(bytesToHex(state.srp_B), 16);\n  const g = int2bigInt(algo.g, 32, 256);\n\n  //log('p', bigInt2str(p, 16));\n  //log('B', bigInt2str(B, 16));\n\n  /* if(B.compareTo(BigInteger.ZERO) < 0) {\n    console.error('srp_B < 0')\n  }\n\n  if(B.compareTo(p) <= 0) {\n    console.error('srp_B <= p');\n  } */\n\n  /* let check_prime_and_good = (bytes: any, g: number) => {\n    let good_prime = 'c71caeb9c6b1c9048e6c522f70f13f73980d40238e3e21c14934d037563d930f48198a0aa7c14058229493d22530f4dbfa336f6e0ac925139543aed44cce7c3720fd51f69458705ac68cd4fe6b6b13abdc9746512969328454f18faf8c595f642477fe96bb2a941d5bcd1d4ac8cc49880708fa9b378e3c4f3a9060bee67cf9a4a4a695811051907e162753b56b0f6b410dba74d8a84b2a14b3144e0ef1284754fd17ed950d5965b4b9dd46582db1178d169c6bc465b0d6ff9ca3928fef5b9ae4e418fc15e83ebea0f87fa9ff5eed70050ded2849f47bf959d956850ce929851f0d8115f635b105ee2e4e15d04b2454bf6f4fadf034b10403119cd8e3b92fcc5b';\n    \n    if(bytesToHex(bytes) === good_prime && [3, 4, 5, 7].indexOf(g) !== -1) {\n      return true;\n    }\n\n    // TO-DO check_prime_and_good_check\n  }; */\n\n  //check_prime_and_good(algo.p, g);\n\n  const pw_hash = await makePasswordHash(password, new Uint8Array(algo.salt1), new Uint8Array(algo.salt2));\n  const x = str2bigInt(bytesToHex(new Uint8Array(pw_hash)), 16);\n\n  //log('computed pw_hash:', pw_hash, x, bytesToHex(new Uint8Array(pw_hash)));\n\n  const padArray = function(arr: any[], len: number, fill = 0) {\n    return new Uint8Array(Array(len).fill(fill).concat(arr).slice(-len));\n  };\n\n  const pForHash = padArray(bytesFromHex(bigInt2str(p, 16)), 256);\n  const gForHash = padArray(bytesFromHex(bigInt2str(g, 16)), 256); // like uint8array\n  const b_for_hash = padArray(bytesFromHex(bigInt2str(B, 16)), 256);\n\n  /* log(bytesToHex(pForHash));\n  log(bytesToHex(gForHash));\n  log(bytesToHex(b_for_hash)); */\n\n  const v = powMod(g, x, p);\n\n  const flipper = (arr: Uint8Array | number[]) => {\n    const out = new Uint8Array(arr.length);\n    for(let i = 0; i < arr.length; i += 4) {\n      out[i] = arr[i + 3];\n      out[i + 1] = arr[i + 2];\n      out[i + 2] = arr[i + 1];\n      out[i + 3] = arr[i];\n    }\n  \n    return out;\n  };\n\n  // * https://core.telegram.org/api/srp#setting-a-new-2fa-password\n  if(isNew) {\n    const bytes = bytesFromHex(bigInt2str(v, 16));\n    return padArray(/* (isBigEndian ? bytes.reverse() : bytes) */bytes, 256);\n  }\n\n  //log('g_x', bigInt2str(g_x, 16));\n\n  let k: any = await CryptoWorker.sha256Hash(bufferConcat(pForHash, gForHash));\n  k = str2bigInt(bytesToHex(new Uint8Array(k)), 16);\n\n  //log('k', bigInt2str(k, 16));\n\n  // kg_x = (k * g_x) % p\n  const k_v = mod(mult(k, v), p);\n\n  // good\n\n  //log('kg_x', bigInt2str(kg_x, 16));\n\n  const is_good_mod_exp_first = (modexp: any, prime: any) => {\n    const diff = sub(prime, modexp);\n    const min_diff_bits_count = 2048 - 64;\n    const max_mod_exp_size = 256;\n    if(negative(diff) ||\n      bitSize(diff) < min_diff_bits_count || \n      bitSize(modexp) < min_diff_bits_count || \n      Math.floor((bitSize(modexp) + 7) / 8) > max_mod_exp_size)\n        return false;\n    return true;\n  };\n\n  const generate_and_check_random = async() => {\n    while(true) {\n      const a = str2bigInt(bytesToHex(flipper(state.secure_random)), 16);\n      //const a = str2bigInt('9153faef8f2bb6da91f6e5bc96bc00860a530a572a0f45aac0842b4602d711f8bda8d59fb53705e4ae3e31a3c4f0681955425f224297b8e9efd898fec22046debb7ba8a0bcf2be1ada7b100424ea318fdcef6ccfe6d7ab7d978c0eb76a807d4ab200eb767a22de0d828bc53f42c5a35c2df6e6ceeef9a3487aae8e9ef2271f2f6742e83b8211161fb1a0e037491ab2c2c73ad63c8bd1d739de1b523fe8d461270cedcf240de8da75f31be4933576532955041dc5770c18d3e75d0b357df9da4a5c8726d4fced87d15752400883dc57fa1937ac17608c5446c4774dcd123676d683ce3a1ab9f7e020ca52faafc99969822717c8e07ea383d5fb1a007ba0d170cb', 16);\n\n      //console.log('ITERATION');\n\n      //log('g a p', bigInt2str(g, 16), bigInt2str(a, 16), bigInt2str(p, 16));\n\n      const A = powMod(g, a, p);\n      //log('A MODPOW', bigInt2str(A, 16));\n      if(is_good_mod_exp_first(A, p)) {\n        const a_for_hash = bytesFromHex(bigInt2str(A, 16));\n\n        const s: any = await CryptoWorker.sha256Hash(\n          bufferConcat(new Uint8Array(a_for_hash), new Uint8Array(b_for_hash)));\n        const u = str2bigInt(bytesToHex(new Uint8Array(s)), 16);\n        if(!isZero(u) && !negative(u))\n          return {a, a_for_hash, u};\n      } \n    }\n  }\n    \n\n  let {a, a_for_hash, u} = await generate_and_check_random();\n\n  /* log('a', bigInt2str(a, 16));\n  log('a_for_hash', bytesToHex(a_for_hash));\n  log('u', bigInt2str(u, 16)); */\n\n  // g_b = (B - kg_x) % p\n  /* log('B - kg_x', bigInt2str(sub(B, kg_x), 16));\n  log('subtract', bigInt2str(B, 16), bigInt2str(kg_x, 16));\n  log('B - kg_x', bigInt2str(sub(B, kg_x), 16)); */\n\n  let g_b;\n  if(!greater(B, k_v)) {\n    //log('negative');\n    g_b = add(B, p);\n  } else g_b = B;\n  g_b = mod(sub(g_b, k_v), p);\n  /* let g_b = sub(B, kg_x);\n  if(negative(g_b)) g_b = add(g_b, p); */\n  \n  //log('g_b', bigInt2str(g_b, 16));\n\n  /* if(!is_good_mod_exp_first(g_b, p))\n    throw new Error('bad g_b'); */\n\n  let ux = mult(u, x);\n  //log('u and x multiply', bigInt2str(u, 16), bigInt2str(x, 16), bigInt2str(ux, 16));\n  let a_ux = add(a, ux);\n  let S = powMod(g_b, a_ux, p);\n\n  let K = await CryptoWorker.sha256Hash(padArray(bytesFromHex(bigInt2str(S, 16)), 256));\n\n  //log('K', bytesToHex(K), new Uint32Array(new Uint8Array(K).buffer));\n\n  let h1 = await CryptoWorker.sha256Hash(pForHash);\n  let h2 = await CryptoWorker.sha256Hash(gForHash);\n  h1 = bytesXor(new Uint8Array(h1), new Uint8Array(h2));\n\n  let buff = bufferConcats(h1, \n    await CryptoWorker.sha256Hash(algo.salt1),\n    await CryptoWorker.sha256Hash(algo.salt2),\n    a_for_hash,\n    b_for_hash,\n    K\n  );\n\n  let M1: any = await CryptoWorker.sha256Hash(buff);\n\n  let out = {\n    _: 'inputCheckPasswordSRP', \n    srp_id: state.srp_id, \n    A: new Uint8Array(a_for_hash), \n    M1: new Uint8Array(M1) \n  };\n\n\n  //log('out', bytesToHex(out.A), bytesToHex(out.M1));\n  return out;\n  \n  /* console.log(gForHash, pForHash, bForHash); */\n}\n"],"sourceRoot":""}